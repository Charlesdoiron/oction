/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/streamx";
exports.ids = ["vendor-chunks/streamx"];
exports.modules = {

/***/ "(rsc)/./node_modules/streamx/index.js":
/*!***************************************!*\
  !*** ./node_modules/streamx/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { EventEmitter } = __webpack_require__(/*! events */ \"events\")\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst queueTick = __webpack_require__(/*! queue-tick */ \"(rsc)/./node_modules/queue-tick/process-next-tick.js\")\nconst FIFO = __webpack_require__(/*! fast-fifo */ \"(rsc)/./node_modules/fast-fifo/index.js\")\nconst TextDecoder = __webpack_require__(/*! text-decoder */ \"(rsc)/./node_modules/text-decoder/index.js\")\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = (stream._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3RyZWFteC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3pDO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMsd0VBQVk7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLDBEQUFXO0FBQ2hDLG9CQUFvQixtQkFBTyxDQUFDLGdFQUFjOztBQUUxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5QixpRkFBaUYsSUFBSTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGlGQUFpRixJQUFJO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsOEJBQThCO0FBQzVGO0FBQ0E7QUFDQSx5QkFBeUIsOEJBQThCO0FBQ3ZELFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0MsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdWN0aW9uLXNjcmFwcGVyLy4vbm9kZV9tb2R1bGVzL3N0cmVhbXgvaW5kZXguanM/NGNmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IFNUUkVBTV9ERVNUUk9ZRUQgPSBuZXcgRXJyb3IoJ1N0cmVhbSB3YXMgZGVzdHJveWVkJylcbmNvbnN0IFBSRU1BVFVSRV9DTE9TRSA9IG5ldyBFcnJvcignUHJlbWF0dXJlIGNsb3NlJylcblxuY29uc3QgcXVldWVUaWNrID0gcmVxdWlyZSgncXVldWUtdGljaycpXG5jb25zdCBGSUZPID0gcmVxdWlyZSgnZmFzdC1maWZvJylcbmNvbnN0IFRleHREZWNvZGVyID0gcmVxdWlyZSgndGV4dC1kZWNvZGVyJylcblxuLyogZXNsaW50LWRpc2FibGUgbm8tbXVsdGktc3BhY2VzICovXG5cbi8vIDI5IGJpdHMgdXNlZCB0b3RhbCAoNCBmcm9tIHNoYXJlZCwgMTQgZnJvbSByZWFkLCBhbmQgMTEgZnJvbSB3cml0ZSlcbmNvbnN0IE1BWCA9ICgoMSA8PCAyOSkgLSAxKVxuXG4vLyBTaGFyZWQgc3RhdGVcbmNvbnN0IE9QRU5JTkcgICAgICAgPSAwYjAwMDFcbmNvbnN0IFBSRURFU1RST1lJTkcgPSAwYjAwMTBcbmNvbnN0IERFU1RST1lJTkcgICAgPSAwYjAxMDBcbmNvbnN0IERFU1RST1lFRCAgICAgPSAwYjEwMDBcblxuY29uc3QgTk9UX09QRU5JTkcgPSBNQVggXiBPUEVOSU5HXG5jb25zdCBOT1RfUFJFREVTVFJPWUlORyA9IE1BWCBeIFBSRURFU1RST1lJTkdcblxuLy8gUmVhZCBzdGF0ZSAoNCBiaXQgb2Zmc2V0IGZyb20gc2hhcmVkIHN0YXRlKVxuY29uc3QgUkVBRF9BQ1RJVkUgICAgICAgICAgID0gMGIwMDAwMDAwMDAwMDAwMSA8PCA0XG5jb25zdCBSRUFEX1VQREFUSU5HICAgICAgICAgPSAwYjAwMDAwMDAwMDAwMDEwIDw8IDRcbmNvbnN0IFJFQURfUFJJTUFSWSAgICAgICAgICA9IDBiMDAwMDAwMDAwMDAxMDAgPDwgNFxuY29uc3QgUkVBRF9RVUVVRUQgICAgICAgICAgID0gMGIwMDAwMDAwMDAwMTAwMCA8PCA0XG5jb25zdCBSRUFEX1JFU1VNRUQgICAgICAgICAgPSAwYjAwMDAwMDAwMDEwMDAwIDw8IDRcbmNvbnN0IFJFQURfUElQRV9EUkFJTkVEICAgICA9IDBiMDAwMDAwMDAxMDAwMDAgPDwgNFxuY29uc3QgUkVBRF9FTkRJTkcgICAgICAgICAgID0gMGIwMDAwMDAwMTAwMDAwMCA8PCA0XG5jb25zdCBSRUFEX0VNSVRfREFUQSAgICAgICAgPSAwYjAwMDAwMDEwMDAwMDAwIDw8IDRcbmNvbnN0IFJFQURfRU1JVF9SRUFEQUJMRSAgICA9IDBiMDAwMDAxMDAwMDAwMDAgPDwgNFxuY29uc3QgUkVBRF9FTUlUVEVEX1JFQURBQkxFID0gMGIwMDAwMTAwMDAwMDAwMCA8PCA0XG5jb25zdCBSRUFEX0RPTkUgICAgICAgICAgICAgPSAwYjAwMDEwMDAwMDAwMDAwIDw8IDRcbmNvbnN0IFJFQURfTkVYVF9USUNLICAgICAgICA9IDBiMDAxMDAwMDAwMDAwMDAgPDwgNFxuY29uc3QgUkVBRF9ORUVEU19QVVNIICAgICAgID0gMGIwMTAwMDAwMDAwMDAwMCA8PCA0XG5jb25zdCBSRUFEX1JFQURfQUhFQUQgICAgICAgPSAwYjEwMDAwMDAwMDAwMDAwIDw8IDRcblxuLy8gQ29tYmluZWQgcmVhZCBzdGF0ZVxuY29uc3QgUkVBRF9GTE9XSU5HID0gUkVBRF9SRVNVTUVEIHwgUkVBRF9QSVBFX0RSQUlORURcbmNvbnN0IFJFQURfQUNUSVZFX0FORF9ORUVEU19QVVNIID0gUkVBRF9BQ1RJVkUgfCBSRUFEX05FRURTX1BVU0hcbmNvbnN0IFJFQURfUFJJTUFSWV9BTkRfQUNUSVZFID0gUkVBRF9QUklNQVJZIHwgUkVBRF9BQ1RJVkVcbmNvbnN0IFJFQURfRU1JVF9SRUFEQUJMRV9BTkRfUVVFVUVEID0gUkVBRF9FTUlUX1JFQURBQkxFIHwgUkVBRF9RVUVVRURcbmNvbnN0IFJFQURfUkVTVU1FRF9SRUFEX0FIRUFEID0gUkVBRF9SRVNVTUVEIHwgUkVBRF9SRUFEX0FIRUFEXG5cbmNvbnN0IFJFQURfTk9UX0FDVElWRSAgICAgICAgICAgICA9IE1BWCBeIFJFQURfQUNUSVZFXG5jb25zdCBSRUFEX05PTl9QUklNQVJZICAgICAgICAgICAgPSBNQVggXiBSRUFEX1BSSU1BUllcbmNvbnN0IFJFQURfTk9OX1BSSU1BUllfQU5EX1BVU0hFRCA9IE1BWCBeIChSRUFEX1BSSU1BUlkgfCBSRUFEX05FRURTX1BVU0gpXG5jb25zdCBSRUFEX1BVU0hFRCAgICAgICAgICAgICAgICAgPSBNQVggXiBSRUFEX05FRURTX1BVU0hcbmNvbnN0IFJFQURfUEFVU0VEICAgICAgICAgICAgICAgICA9IE1BWCBeIFJFQURfUkVTVU1FRFxuY29uc3QgUkVBRF9OT1RfUVVFVUVEICAgICAgICAgICAgID0gTUFYIF4gKFJFQURfUVVFVUVEIHwgUkVBRF9FTUlUVEVEX1JFQURBQkxFKVxuY29uc3QgUkVBRF9OT1RfRU5ESU5HICAgICAgICAgICAgID0gTUFYIF4gUkVBRF9FTkRJTkdcbmNvbnN0IFJFQURfUElQRV9OT1RfRFJBSU5FRCAgICAgICA9IE1BWCBeIFJFQURfRkxPV0lOR1xuY29uc3QgUkVBRF9OT1RfTkVYVF9USUNLICAgICAgICAgID0gTUFYIF4gUkVBRF9ORVhUX1RJQ0tcbmNvbnN0IFJFQURfTk9UX1VQREFUSU5HICAgICAgICAgICA9IE1BWCBeIFJFQURfVVBEQVRJTkdcbmNvbnN0IFJFQURfTk9fUkVBRF9BSEVBRCAgICAgICAgICA9IE1BWCBeIFJFQURfUkVBRF9BSEVBRFxuY29uc3QgUkVBRF9QQVVTRURfTk9fUkVBRF9BSEVBRCAgID0gTUFYIF4gUkVBRF9SRVNVTUVEX1JFQURfQUhFQURcblxuLy8gV3JpdGUgc3RhdGUgKDE4IGJpdCBvZmZzZXQsIDQgYml0IG9mZnNldCBmcm9tIHNoYXJlZCBzdGF0ZSBhbmQgMTQgZnJvbSByZWFkIHN0YXRlKVxuY29uc3QgV1JJVEVfQUNUSVZFICAgICA9IDBiMDAwMDAwMDAwMDEgPDwgMThcbmNvbnN0IFdSSVRFX1VQREFUSU5HICAgPSAwYjAwMDAwMDAwMDEwIDw8IDE4XG5jb25zdCBXUklURV9QUklNQVJZICAgID0gMGIwMDAwMDAwMDEwMCA8PCAxOFxuY29uc3QgV1JJVEVfUVVFVUVEICAgICA9IDBiMDAwMDAwMDEwMDAgPDwgMThcbmNvbnN0IFdSSVRFX1VORFJBSU5FRCAgPSAwYjAwMDAwMDEwMDAwIDw8IDE4XG5jb25zdCBXUklURV9ET05FICAgICAgID0gMGIwMDAwMDEwMDAwMCA8PCAxOFxuY29uc3QgV1JJVEVfRU1JVF9EUkFJTiA9IDBiMDAwMDEwMDAwMDAgPDwgMThcbmNvbnN0IFdSSVRFX05FWFRfVElDSyAgPSAwYjAwMDEwMDAwMDAwIDw8IDE4XG5jb25zdCBXUklURV9XUklUSU5HICAgID0gMGIwMDEwMDAwMDAwMCA8PCAxOFxuY29uc3QgV1JJVEVfRklOSVNISU5HICA9IDBiMDEwMDAwMDAwMDAgPDwgMThcbmNvbnN0IFdSSVRFX0NPUktFRCAgICAgPSAwYjEwMDAwMDAwMDAwIDw8IDE4XG5cbmNvbnN0IFdSSVRFX05PVF9BQ1RJVkUgICAgPSBNQVggXiAoV1JJVEVfQUNUSVZFIHwgV1JJVEVfV1JJVElORylcbmNvbnN0IFdSSVRFX05PTl9QUklNQVJZICAgPSBNQVggXiBXUklURV9QUklNQVJZXG5jb25zdCBXUklURV9OT1RfRklOSVNISU5HID0gTUFYIF4gV1JJVEVfRklOSVNISU5HXG5jb25zdCBXUklURV9EUkFJTkVEICAgICAgID0gTUFYIF4gV1JJVEVfVU5EUkFJTkVEXG5jb25zdCBXUklURV9OT1RfUVVFVUVEICAgID0gTUFYIF4gV1JJVEVfUVVFVUVEXG5jb25zdCBXUklURV9OT1RfTkVYVF9USUNLID0gTUFYIF4gV1JJVEVfTkVYVF9USUNLXG5jb25zdCBXUklURV9OT1RfVVBEQVRJTkcgID0gTUFYIF4gV1JJVEVfVVBEQVRJTkdcbmNvbnN0IFdSSVRFX05PVF9DT1JLRUQgICAgPSBNQVggXiBXUklURV9DT1JLRURcblxuLy8gQ29tYmluZWQgc2hhcmVkIHN0YXRlXG5jb25zdCBBQ1RJVkUgPSBSRUFEX0FDVElWRSB8IFdSSVRFX0FDVElWRVxuY29uc3QgTk9UX0FDVElWRSA9IE1BWCBeIEFDVElWRVxuY29uc3QgRE9ORSA9IFJFQURfRE9ORSB8IFdSSVRFX0RPTkVcbmNvbnN0IERFU1RST1lfU1RBVFVTID0gREVTVFJPWUlORyB8IERFU1RST1lFRCB8IFBSRURFU1RST1lJTkdcbmNvbnN0IE9QRU5fU1RBVFVTID0gREVTVFJPWV9TVEFUVVMgfCBPUEVOSU5HXG5jb25zdCBBVVRPX0RFU1RST1kgPSBERVNUUk9ZX1NUQVRVUyB8IERPTkVcbmNvbnN0IE5PTl9QUklNQVJZID0gV1JJVEVfTk9OX1BSSU1BUlkgJiBSRUFEX05PTl9QUklNQVJZXG5jb25zdCBBQ1RJVkVfT1JfVElDS0lORyA9IFdSSVRFX05FWFRfVElDSyB8IFJFQURfTkVYVF9USUNLXG5jb25zdCBUSUNLSU5HID0gQUNUSVZFX09SX1RJQ0tJTkcgJiBOT1RfQUNUSVZFXG5jb25zdCBJU19PUEVOSU5HID0gT1BFTl9TVEFUVVMgfCBUSUNLSU5HXG5cbi8vIENvbWJpbmVkIHNoYXJlZCBzdGF0ZSBhbmQgcmVhZCBzdGF0ZVxuY29uc3QgUkVBRF9QUklNQVJZX1NUQVRVUyA9IE9QRU5fU1RBVFVTIHwgUkVBRF9FTkRJTkcgfCBSRUFEX0RPTkVcbmNvbnN0IFJFQURfU1RBVFVTID0gT1BFTl9TVEFUVVMgfCBSRUFEX0RPTkUgfCBSRUFEX1FVRVVFRFxuY29uc3QgUkVBRF9FTkRJTkdfU1RBVFVTID0gT1BFTl9TVEFUVVMgfCBSRUFEX0VORElORyB8IFJFQURfUVVFVUVEXG5jb25zdCBSRUFEX1JFQURBQkxFX1NUQVRVUyA9IE9QRU5fU1RBVFVTIHwgUkVBRF9FTUlUX1JFQURBQkxFIHwgUkVBRF9RVUVVRUQgfCBSRUFEX0VNSVRURURfUkVBREFCTEVcbmNvbnN0IFNIT1VMRF9OT1RfUkVBRCA9IE9QRU5fU1RBVFVTIHwgUkVBRF9BQ1RJVkUgfCBSRUFEX0VORElORyB8IFJFQURfRE9ORSB8IFJFQURfTkVFRFNfUFVTSCB8IFJFQURfUkVBRF9BSEVBRFxuY29uc3QgUkVBRF9CQUNLUFJFU1NVUkVfU1RBVFVTID0gREVTVFJPWV9TVEFUVVMgfCBSRUFEX0VORElORyB8IFJFQURfRE9ORVxuY29uc3QgUkVBRF9VUERBVEVfU1lOQ19TVEFUVVMgPSBSRUFEX1VQREFUSU5HIHwgT1BFTl9TVEFUVVMgfCBSRUFEX05FWFRfVElDSyB8IFJFQURfUFJJTUFSWVxuXG4vLyBDb21iaW5lZCB3cml0ZSBzdGF0ZVxuY29uc3QgV1JJVEVfUFJJTUFSWV9TVEFUVVMgPSBPUEVOX1NUQVRVUyB8IFdSSVRFX0ZJTklTSElORyB8IFdSSVRFX0RPTkVcbmNvbnN0IFdSSVRFX1FVRVVFRF9BTkRfVU5EUkFJTkVEID0gV1JJVEVfUVVFVUVEIHwgV1JJVEVfVU5EUkFJTkVEXG5jb25zdCBXUklURV9RVUVVRURfQU5EX0FDVElWRSA9IFdSSVRFX1FVRVVFRCB8IFdSSVRFX0FDVElWRVxuY29uc3QgV1JJVEVfRFJBSU5fU1RBVFVTID0gV1JJVEVfUVVFVUVEIHwgV1JJVEVfVU5EUkFJTkVEIHwgT1BFTl9TVEFUVVMgfCBXUklURV9BQ1RJVkVcbmNvbnN0IFdSSVRFX1NUQVRVUyA9IE9QRU5fU1RBVFVTIHwgV1JJVEVfQUNUSVZFIHwgV1JJVEVfUVVFVUVEIHwgV1JJVEVfQ09SS0VEXG5jb25zdCBXUklURV9QUklNQVJZX0FORF9BQ1RJVkUgPSBXUklURV9QUklNQVJZIHwgV1JJVEVfQUNUSVZFXG5jb25zdCBXUklURV9BQ1RJVkVfQU5EX1dSSVRJTkcgPSBXUklURV9BQ1RJVkUgfCBXUklURV9XUklUSU5HXG5jb25zdCBXUklURV9GSU5JU0hJTkdfU1RBVFVTID0gT1BFTl9TVEFUVVMgfCBXUklURV9GSU5JU0hJTkcgfCBXUklURV9RVUVVRURfQU5EX0FDVElWRSB8IFdSSVRFX0RPTkVcbmNvbnN0IFdSSVRFX0JBQ0tQUkVTU1VSRV9TVEFUVVMgPSBXUklURV9VTkRSQUlORUQgfCBERVNUUk9ZX1NUQVRVUyB8IFdSSVRFX0ZJTklTSElORyB8IFdSSVRFX0RPTkVcbmNvbnN0IFdSSVRFX1VQREFURV9TWU5DX1NUQVRVUyA9IFdSSVRFX1VQREFUSU5HIHwgT1BFTl9TVEFUVVMgfCBXUklURV9ORVhUX1RJQ0sgfCBXUklURV9QUklNQVJZXG5cbmNvbnN0IGFzeW5jSXRlcmF0b3IgPSBTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBTeW1ib2woJ2FzeW5jSXRlcmF0b3InKVxuXG5jbGFzcyBXcml0YWJsZVN0YXRlIHtcbiAgY29uc3RydWN0b3IgKHN0cmVhbSwgeyBoaWdoV2F0ZXJNYXJrID0gMTYzODQsIG1hcCA9IG51bGwsIG1hcFdyaXRhYmxlLCBieXRlTGVuZ3RoLCBieXRlTGVuZ3RoV3JpdGFibGUgfSA9IHt9KSB7XG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW1cbiAgICB0aGlzLnF1ZXVlID0gbmV3IEZJRk8oKVxuICAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IGhpZ2hXYXRlck1hcmtcbiAgICB0aGlzLmJ1ZmZlcmVkID0gMFxuICAgIHRoaXMuZXJyb3IgPSBudWxsXG4gICAgdGhpcy5waXBlbGluZSA9IG51bGxcbiAgICB0aGlzLmRyYWlucyA9IG51bGwgLy8gaWYgd2UgYWRkIG1vcmUgc2VsZG9tbHkgdXNlZCBoZWxwZXJzIHdlIG1pZ2h0IHRoZW0gaW50byBhIHN1Ym9iamVjdCBzbyBpdHMgYSBzaW5nbGUgcHRyXG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFdyaXRhYmxlIHx8IGJ5dGVMZW5ndGggfHwgZGVmYXVsdEJ5dGVMZW5ndGhcbiAgICB0aGlzLm1hcCA9IG1hcFdyaXRhYmxlIHx8IG1hcFxuICAgIHRoaXMuYWZ0ZXJXcml0ZSA9IGFmdGVyV3JpdGUuYmluZCh0aGlzKVxuICAgIHRoaXMuYWZ0ZXJVcGRhdGVOZXh0VGljayA9IHVwZGF0ZVdyaXRlTlQuYmluZCh0aGlzKVxuICB9XG5cbiAgZ2V0IGVuZGVkICgpIHtcbiAgICByZXR1cm4gKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX0RPTkUpICE9PSAwXG4gIH1cblxuICBwdXNoIChkYXRhKSB7XG4gICAgaWYgKHRoaXMubWFwICE9PSBudWxsKSBkYXRhID0gdGhpcy5tYXAoZGF0YSlcblxuICAgIHRoaXMuYnVmZmVyZWQgKz0gdGhpcy5ieXRlTGVuZ3RoKGRhdGEpXG4gICAgdGhpcy5xdWV1ZS5wdXNoKGRhdGEpXG5cbiAgICBpZiAodGhpcy5idWZmZXJlZCA8IHRoaXMuaGlnaFdhdGVyTWFyaykge1xuICAgICAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlIHw9IFdSSVRFX1FVRVVFRFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfUVVFVUVEX0FORF9VTkRSQUlORURcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHNoaWZ0ICgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5xdWV1ZS5zaGlmdCgpXG5cbiAgICB0aGlzLmJ1ZmZlcmVkIC09IHRoaXMuYnl0ZUxlbmd0aChkYXRhKVxuICAgIGlmICh0aGlzLmJ1ZmZlcmVkID09PSAwKSB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gV1JJVEVfTk9UX1FVRVVFRFxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGVuZCAoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5zdHJlYW0ub25jZSgnZmluaXNoJywgZGF0YSlcbiAgICBlbHNlIGlmIChkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YSAhPT0gbnVsbCkgdGhpcy5wdXNoKGRhdGEpXG4gICAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlID0gKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSB8IFdSSVRFX0ZJTklTSElORykgJiBXUklURV9OT05fUFJJTUFSWVxuICB9XG5cbiAgYXV0b0JhdGNoIChkYXRhLCBjYikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdXG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5zdHJlYW1cblxuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgd2hpbGUgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfU1RBVFVTKSA9PT0gV1JJVEVfUVVFVUVEX0FORF9BQ1RJVkUpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5zaGlmdCgpKVxuICAgIH1cblxuICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIE9QRU5fU1RBVFVTKSAhPT0gMCkgcmV0dXJuIGNiKG51bGwpXG4gICAgc3RyZWFtLl93cml0ZXYoYnVmZmVyLCBjYilcbiAgfVxuXG4gIHVwZGF0ZSAoKSB7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5zdHJlYW1cblxuICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfVVBEQVRJTkdcblxuICAgIGRvIHtcbiAgICAgIHdoaWxlICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX1NUQVRVUykgPT09IFdSSVRFX1FVRVVFRCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5zaGlmdCgpXG4gICAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfQUNUSVZFX0FORF9XUklUSU5HXG4gICAgICAgIHN0cmVhbS5fd3JpdGUoZGF0YSwgdGhpcy5hZnRlcldyaXRlKVxuICAgICAgfVxuXG4gICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9QUklNQVJZX0FORF9BQ1RJVkUpID09PSAwKSB0aGlzLnVwZGF0ZU5vblByaW1hcnkoKVxuICAgIH0gd2hpbGUgKHRoaXMuY29udGludWVVcGRhdGUoKSA9PT0gdHJ1ZSlcblxuICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gV1JJVEVfTk9UX1VQREFUSU5HXG4gIH1cblxuICB1cGRhdGVOb25QcmltYXJ5ICgpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfRklOSVNISU5HX1NUQVRVUykgPT09IFdSSVRFX0ZJTklTSElORykge1xuICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSA9IChzdHJlYW0uX2R1cGxleFN0YXRlIHwgV1JJVEVfQUNUSVZFKSAmIFdSSVRFX05PVF9GSU5JU0hJTkdcbiAgICAgIHN0cmVhbS5fZmluYWwoYWZ0ZXJGaW5hbC5iaW5kKHRoaXMpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgREVTVFJPWV9TVEFUVVMpID09PSBERVNUUk9ZSU5HKSB7XG4gICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBBQ1RJVkVfT1JfVElDS0lORykgPT09IDApIHtcbiAgICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBBQ1RJVkVcbiAgICAgICAgc3RyZWFtLl9kZXN0cm95KGFmdGVyRGVzdHJveS5iaW5kKHRoaXMpKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgSVNfT1BFTklORykgPT09IE9QRU5JTkcpIHtcbiAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgPSAoc3RyZWFtLl9kdXBsZXhTdGF0ZSB8IEFDVElWRSkgJiBOT1RfT1BFTklOR1xuICAgICAgc3RyZWFtLl9vcGVuKGFmdGVyT3Blbi5iaW5kKHRoaXMpKVxuICAgIH1cbiAgfVxuXG4gIGNvbnRpbnVlVXBkYXRlICgpIHtcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX05FWFRfVElDSykgPT09IDApIHJldHVybiBmYWxzZVxuICAgIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBXUklURV9OT1RfTkVYVF9USUNLXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHVwZGF0ZUNhbGxiYWNrICgpIHtcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX1VQREFURV9TWU5DX1NUQVRVUykgPT09IFdSSVRFX1BSSU1BUlkpIHRoaXMudXBkYXRlKClcbiAgICBlbHNlIHRoaXMudXBkYXRlTmV4dFRpY2soKVxuICB9XG5cbiAgdXBkYXRlTmV4dFRpY2sgKCkge1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfTkVYVF9USUNLKSAhPT0gMCkgcmV0dXJuXG4gICAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlIHw9IFdSSVRFX05FWFRfVElDS1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfVVBEQVRJTkcpID09PSAwKSBxdWV1ZVRpY2sodGhpcy5hZnRlclVwZGF0ZU5leHRUaWNrKVxuICB9XG59XG5cbmNsYXNzIFJlYWRhYmxlU3RhdGUge1xuICBjb25zdHJ1Y3RvciAoc3RyZWFtLCB7IGhpZ2hXYXRlck1hcmsgPSAxNjM4NCwgbWFwID0gbnVsbCwgbWFwUmVhZGFibGUsIGJ5dGVMZW5ndGgsIGJ5dGVMZW5ndGhSZWFkYWJsZSB9ID0ge30pIHtcbiAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbVxuICAgIHRoaXMucXVldWUgPSBuZXcgRklGTygpXG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaGlnaFdhdGVyTWFyayA9PT0gMCA/IDEgOiBoaWdoV2F0ZXJNYXJrXG4gICAgdGhpcy5idWZmZXJlZCA9IDBcbiAgICB0aGlzLnJlYWRBaGVhZCA9IGhpZ2hXYXRlck1hcmsgPiAwXG4gICAgdGhpcy5lcnJvciA9IG51bGxcbiAgICB0aGlzLnBpcGVsaW5lID0gbnVsbFxuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhSZWFkYWJsZSB8fCBieXRlTGVuZ3RoIHx8IGRlZmF1bHRCeXRlTGVuZ3RoXG4gICAgdGhpcy5tYXAgPSBtYXBSZWFkYWJsZSB8fCBtYXBcbiAgICB0aGlzLnBpcGVUbyA9IG51bGxcbiAgICB0aGlzLmFmdGVyUmVhZCA9IGFmdGVyUmVhZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5hZnRlclVwZGF0ZU5leHRUaWNrID0gdXBkYXRlUmVhZE5ULmJpbmQodGhpcylcbiAgfVxuXG4gIGdldCBlbmRlZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX0RPTkUpICE9PSAwXG4gIH1cblxuICBwaXBlIChwaXBlVG8sIGNiKSB7XG4gICAgaWYgKHRoaXMucGlwZVRvICE9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHBpcGUgdG8gb25lIGRlc3RpbmF0aW9uJylcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG51bGxcblxuICAgIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBSRUFEX1BJUEVfRFJBSU5FRFxuICAgIHRoaXMucGlwZVRvID0gcGlwZVRvXG4gICAgdGhpcy5waXBlbGluZSA9IG5ldyBQaXBlbGluZSh0aGlzLnN0cmVhbSwgcGlwZVRvLCBjYilcblxuICAgIGlmIChjYikgdGhpcy5zdHJlYW0ub24oJ2Vycm9yJywgbm9vcCkgLy8gV2UgYWxyZWFkeSBlcnJvciBoYW5kbGUgdGhpcyBzbyBzdXByZXNzIGNyYXNoZXNcblxuICAgIGlmIChpc1N0cmVhbXgocGlwZVRvKSkge1xuICAgICAgcGlwZVRvLl93cml0YWJsZVN0YXRlLnBpcGVsaW5lID0gdGhpcy5waXBlbGluZVxuICAgICAgaWYgKGNiKSBwaXBlVG8ub24oJ2Vycm9yJywgbm9vcCkgLy8gV2UgYWxyZWFkeSBlcnJvciBoYW5kbGUgdGhpcyBzbyBzdXByZXNzIGNyYXNoZXNcbiAgICAgIHBpcGVUby5vbignZmluaXNoJywgdGhpcy5waXBlbGluZS5maW5pc2hlZC5iaW5kKHRoaXMucGlwZWxpbmUpKSAvLyBUT0RPOiBqdXN0IGNhbGwgZmluaXNoZWQgZnJvbSBwaXBlVG8gaXRzZWxmXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9uZXJyb3IgPSB0aGlzLnBpcGVsaW5lLmRvbmUuYmluZCh0aGlzLnBpcGVsaW5lLCBwaXBlVG8pXG4gICAgICBjb25zdCBvbmNsb3NlID0gdGhpcy5waXBlbGluZS5kb25lLmJpbmQodGhpcy5waXBlbGluZSwgcGlwZVRvLCBudWxsKSAvLyBvbmNsb3NlIGhhcyBhIHdlaXJkIGJvb2wgYXJnXG4gICAgICBwaXBlVG8ub24oJ2Vycm9yJywgb25lcnJvcilcbiAgICAgIHBpcGVUby5vbignY2xvc2UnLCBvbmNsb3NlKVxuICAgICAgcGlwZVRvLm9uKCdmaW5pc2gnLCB0aGlzLnBpcGVsaW5lLmZpbmlzaGVkLmJpbmQodGhpcy5waXBlbGluZSkpXG4gICAgfVxuXG4gICAgcGlwZVRvLm9uKCdkcmFpbicsIGFmdGVyRHJhaW4uYmluZCh0aGlzKSlcbiAgICB0aGlzLnN0cmVhbS5lbWl0KCdwaXBpbmcnLCBwaXBlVG8pXG4gICAgcGlwZVRvLmVtaXQoJ3BpcGUnLCB0aGlzLnN0cmVhbSlcbiAgfVxuXG4gIHB1c2ggKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IDBcbiAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgPSAoc3RyZWFtLl9kdXBsZXhTdGF0ZSB8IFJFQURfRU5ESU5HKSAmIFJFQURfTk9OX1BSSU1BUllfQU5EX1BVU0hFRFxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWFwICE9PSBudWxsKSB7XG4gICAgICBkYXRhID0gdGhpcy5tYXAoZGF0YSlcbiAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9QVVNIRURcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyZWQgPCB0aGlzLmhpZ2hXYXRlck1hcmtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlcmVkICs9IHRoaXMuYnl0ZUxlbmd0aChkYXRhKVxuICAgIHRoaXMucXVldWUucHVzaChkYXRhKVxuXG4gICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSA9IChzdHJlYW0uX2R1cGxleFN0YXRlIHwgUkVBRF9RVUVVRUQpICYgUkVBRF9QVVNIRURcblxuICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkIDwgdGhpcy5oaWdoV2F0ZXJNYXJrXG4gIH1cblxuICBzaGlmdCAoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucXVldWUuc2hpZnQoKVxuXG4gICAgdGhpcy5idWZmZXJlZCAtPSB0aGlzLmJ5dGVMZW5ndGgoZGF0YSlcbiAgICBpZiAodGhpcy5idWZmZXJlZCA9PT0gMCkgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICY9IFJFQURfTk9UX1FVRVVFRFxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICB1bnNoaWZ0IChkYXRhKSB7XG4gICAgY29uc3QgcGVuZGluZyA9IFt0aGlzLm1hcCAhPT0gbnVsbCA/IHRoaXMubWFwKGRhdGEpIDogZGF0YV1cbiAgICB3aGlsZSAodGhpcy5idWZmZXJlZCA+IDApIHBlbmRpbmcucHVzaCh0aGlzLnNoaWZ0KCkpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmcubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhID0gcGVuZGluZ1tpXVxuICAgICAgdGhpcy5idWZmZXJlZCArPSB0aGlzLmJ5dGVMZW5ndGgoZGF0YSlcbiAgICAgIHRoaXMucXVldWUucHVzaChkYXRhKVxuICAgIH1cblxuICAgIHRoaXMucHVzaChwZW5kaW5nW3BlbmRpbmcubGVuZ3RoIC0gMV0pXG4gIH1cblxuICByZWFkICgpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9TVEFUVVMpID09PSBSRUFEX1FVRVVFRCkge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuc2hpZnQoKVxuICAgICAgaWYgKHRoaXMucGlwZVRvICE9PSBudWxsICYmIHRoaXMucGlwZVRvLndyaXRlKGRhdGEpID09PSBmYWxzZSkgc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBSRUFEX1BJUEVfTk9UX0RSQUlORURcbiAgICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfRU1JVF9EQVRBKSAhPT0gMCkgc3RyZWFtLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkQWhlYWQgPT09IGZhbHNlKSB7XG4gICAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IFJFQURfUkVBRF9BSEVBRFxuICAgICAgdGhpcy51cGRhdGVOZXh0VGljaygpXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGRyYWluICgpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gICAgd2hpbGUgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9TVEFUVVMpID09PSBSRUFEX1FVRVVFRCAmJiAoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfRkxPV0lORykgIT09IDApIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnNoaWZ0KClcbiAgICAgIGlmICh0aGlzLnBpcGVUbyAhPT0gbnVsbCAmJiB0aGlzLnBpcGVUby53cml0ZShkYXRhKSA9PT0gZmFsc2UpIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9QSVBFX05PVF9EUkFJTkVEXG4gICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX0VNSVRfREFUQSkgIT09IDApIHN0cmVhbS5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICB9XG4gIH1cblxuICB1cGRhdGUgKCkge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IFJFQURfVVBEQVRJTkdcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuZHJhaW4oKVxuXG4gICAgICB3aGlsZSAodGhpcy5idWZmZXJlZCA8IHRoaXMuaGlnaFdhdGVyTWFyayAmJiAoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFNIT1VMRF9OT1RfUkVBRCkgPT09IFJFQURfUkVBRF9BSEVBRCkge1xuICAgICAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IFJFQURfQUNUSVZFX0FORF9ORUVEU19QVVNIXG4gICAgICAgIHN0cmVhbS5fcmVhZCh0aGlzLmFmdGVyUmVhZClcbiAgICAgICAgdGhpcy5kcmFpbigpXG4gICAgICB9XG5cbiAgICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfUkVBREFCTEVfU1RBVFVTKSA9PT0gUkVBRF9FTUlUX1JFQURBQkxFX0FORF9RVUVVRUQpIHtcbiAgICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBSRUFEX0VNSVRURURfUkVBREFCTEVcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJylcbiAgICAgIH1cblxuICAgICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9QUklNQVJZX0FORF9BQ1RJVkUpID09PSAwKSB0aGlzLnVwZGF0ZU5vblByaW1hcnkoKVxuICAgIH0gd2hpbGUgKHRoaXMuY29udGludWVVcGRhdGUoKSA9PT0gdHJ1ZSlcblxuICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9OT1RfVVBEQVRJTkdcbiAgfVxuXG4gIHVwZGF0ZU5vblByaW1hcnkgKCkge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX0VORElOR19TVEFUVVMpID09PSBSRUFEX0VORElORykge1xuICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSA9IChzdHJlYW0uX2R1cGxleFN0YXRlIHwgUkVBRF9ET05FKSAmIFJFQURfTk9UX0VORElOR1xuICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpXG4gICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBBVVRPX0RFU1RST1kpID09PSBET05FKSBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IERFU1RST1lJTkdcbiAgICAgIGlmICh0aGlzLnBpcGVUbyAhPT0gbnVsbCkgdGhpcy5waXBlVG8uZW5kKClcbiAgICB9XG5cbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBERVNUUk9ZX1NUQVRVUykgPT09IERFU1RST1lJTkcpIHtcbiAgICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIEFDVElWRV9PUl9USUNLSU5HKSA9PT0gMCkge1xuICAgICAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IEFDVElWRVxuICAgICAgICBzdHJlYW0uX2Rlc3Ryb3koYWZ0ZXJEZXN0cm95LmJpbmQodGhpcykpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBJU19PUEVOSU5HKSA9PT0gT1BFTklORykge1xuICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSA9IChzdHJlYW0uX2R1cGxleFN0YXRlIHwgQUNUSVZFKSAmIE5PVF9PUEVOSU5HXG4gICAgICBzdHJlYW0uX29wZW4oYWZ0ZXJPcGVuLmJpbmQodGhpcykpXG4gICAgfVxuICB9XG5cbiAgY29udGludWVVcGRhdGUgKCkge1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9ORVhUX1RJQ0spID09PSAwKSByZXR1cm4gZmFsc2VcbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9OT1RfTkVYVF9USUNLXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHVwZGF0ZUNhbGxiYWNrICgpIHtcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfVVBEQVRFX1NZTkNfU1RBVFVTKSA9PT0gUkVBRF9QUklNQVJZKSB0aGlzLnVwZGF0ZSgpXG4gICAgZWxzZSB0aGlzLnVwZGF0ZU5leHRUaWNrKClcbiAgfVxuXG4gIHVwZGF0ZU5leHRUaWNrICgpIHtcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfTkVYVF9USUNLKSAhPT0gMCkgcmV0dXJuXG4gICAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlIHw9IFJFQURfTkVYVF9USUNLXG4gICAgaWYgKCh0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX1VQREFUSU5HKSA9PT0gMCkgcXVldWVUaWNrKHRoaXMuYWZ0ZXJVcGRhdGVOZXh0VGljaylcbiAgfVxufVxuXG5jbGFzcyBUcmFuc2Zvcm1TdGF0ZSB7XG4gIGNvbnN0cnVjdG9yIChzdHJlYW0pIHtcbiAgICB0aGlzLmRhdGEgPSBudWxsXG4gICAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGFmdGVyVHJhbnNmb3JtLmJpbmQoc3RyZWFtKVxuICAgIHRoaXMuYWZ0ZXJGaW5hbCA9IG51bGxcbiAgfVxufVxuXG5jbGFzcyBQaXBlbGluZSB7XG4gIGNvbnN0cnVjdG9yIChzcmMsIGRzdCwgY2IpIHtcbiAgICB0aGlzLmZyb20gPSBzcmNcbiAgICB0aGlzLnRvID0gZHN0XG4gICAgdGhpcy5hZnRlclBpcGUgPSBjYlxuICAgIHRoaXMuZXJyb3IgPSBudWxsXG4gICAgdGhpcy5waXBlVG9GaW5pc2hlZCA9IGZhbHNlXG4gIH1cblxuICBmaW5pc2hlZCAoKSB7XG4gICAgdGhpcy5waXBlVG9GaW5pc2hlZCA9IHRydWVcbiAgfVxuXG4gIGRvbmUgKHN0cmVhbSwgZXJyKSB7XG4gICAgaWYgKGVycikgdGhpcy5lcnJvciA9IGVyclxuXG4gICAgaWYgKHN0cmVhbSA9PT0gdGhpcy50bykge1xuICAgICAgdGhpcy50byA9IG51bGxcblxuICAgICAgaWYgKHRoaXMuZnJvbSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoKHRoaXMuZnJvbS5fZHVwbGV4U3RhdGUgJiBSRUFEX0RPTkUpID09PSAwIHx8ICF0aGlzLnBpcGVUb0ZpbmlzaGVkKSB7XG4gICAgICAgICAgdGhpcy5mcm9tLmRlc3Ryb3kodGhpcy5lcnJvciB8fCBuZXcgRXJyb3IoJ1dyaXRhYmxlIHN0cmVhbSBjbG9zZWQgcHJlbWF0dXJlbHknKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RyZWFtID09PSB0aGlzLmZyb20pIHtcbiAgICAgIHRoaXMuZnJvbSA9IG51bGxcblxuICAgICAgaWYgKHRoaXMudG8gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9ET05FKSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMudG8uZGVzdHJveSh0aGlzLmVycm9yIHx8IG5ldyBFcnJvcignUmVhZGFibGUgc3RyZWFtIGNsb3NlZCBiZWZvcmUgZW5kaW5nJykpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWZ0ZXJQaXBlICE9PSBudWxsKSB0aGlzLmFmdGVyUGlwZSh0aGlzLmVycm9yKVxuICAgIHRoaXMudG8gPSB0aGlzLmZyb20gPSB0aGlzLmFmdGVyUGlwZSA9IG51bGxcbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlckRyYWluICgpIHtcbiAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlIHw9IFJFQURfUElQRV9EUkFJTkVEXG4gIHRoaXMudXBkYXRlQ2FsbGJhY2soKVxufVxuXG5mdW5jdGlvbiBhZnRlckZpbmFsIChlcnIpIHtcbiAgY29uc3Qgc3RyZWFtID0gdGhpcy5zdHJlYW1cbiAgaWYgKGVycikgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBERVNUUk9ZX1NUQVRVUykgPT09IDApIHtcbiAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IFdSSVRFX0RPTkVcbiAgICBzdHJlYW0uZW1pdCgnZmluaXNoJylcbiAgfVxuICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBBVVRPX0RFU1RST1kpID09PSBET05FKSB7XG4gICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBERVNUUk9ZSU5HXG4gIH1cblxuICBzdHJlYW0uX2R1cGxleFN0YXRlICY9IFdSSVRFX05PVF9BQ1RJVkVcblxuICAvLyBubyBuZWVkIHRvIHdhaXQgdGhlIGV4dHJhIHRpY2sgaGVyZSwgc28gd2Ugc2hvcnQgY2lyY3VpdCB0aGF0XG4gIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX1VQREFUSU5HKSA9PT0gMCkgdGhpcy51cGRhdGUoKVxuICBlbHNlIHRoaXMudXBkYXRlTmV4dFRpY2soKVxufVxuXG5mdW5jdGlvbiBhZnRlckRlc3Ryb3kgKGVycikge1xuICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gIGlmICghZXJyICYmIHRoaXMuZXJyb3IgIT09IFNUUkVBTV9ERVNUUk9ZRUQpIGVyciA9IHRoaXMuZXJyb3JcbiAgaWYgKGVycikgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKVxuICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IERFU1RST1lFRFxuICBzdHJlYW0uZW1pdCgnY2xvc2UnKVxuXG4gIGNvbnN0IHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlXG5cbiAgaWYgKHJzICE9PSBudWxsICYmIHJzLnBpcGVsaW5lICE9PSBudWxsKSBycy5waXBlbGluZS5kb25lKHN0cmVhbSwgZXJyKVxuXG4gIGlmICh3cyAhPT0gbnVsbCkge1xuICAgIHdoaWxlICh3cy5kcmFpbnMgIT09IG51bGwgJiYgd3MuZHJhaW5zLmxlbmd0aCA+IDApIHdzLmRyYWlucy5zaGlmdCgpLnJlc29sdmUoZmFsc2UpXG4gICAgaWYgKHdzLnBpcGVsaW5lICE9PSBudWxsKSB3cy5waXBlbGluZS5kb25lKHN0cmVhbSwgZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUgKGVycikge1xuICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gIGlmIChlcnIpIHN0cmVhbS5kZXN0cm95KGVycilcbiAgc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBXUklURV9OT1RfQUNUSVZFXG5cbiAgaWYgKHRoaXMuZHJhaW5zICE9PSBudWxsKSB0aWNrRHJhaW5zKHRoaXMuZHJhaW5zKVxuXG4gIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX0RSQUlOX1NUQVRVUykgPT09IFdSSVRFX1VORFJBSU5FRCkge1xuICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gV1JJVEVfRFJBSU5FRFxuICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX0VNSVRfRFJBSU4pID09PSBXUklURV9FTUlUX0RSQUlOKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMudXBkYXRlQ2FsbGJhY2soKVxufVxuXG5mdW5jdGlvbiBhZnRlclJlYWQgKGVycikge1xuICBpZiAoZXJyKSB0aGlzLnN0cmVhbS5kZXN0cm95KGVycilcbiAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICY9IFJFQURfTk9UX0FDVElWRVxuICBpZiAodGhpcy5yZWFkQWhlYWQgPT09IGZhbHNlICYmICh0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX1JFU1VNRUQpID09PSAwKSB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9OT19SRUFEX0FIRUFEXG4gIHRoaXMudXBkYXRlQ2FsbGJhY2soKVxufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWFkTlQgKCkge1xuICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfVVBEQVRJTkcpID09PSAwKSB7XG4gICAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICY9IFJFQURfTk9UX05FWFRfVElDS1xuICAgIHRoaXMudXBkYXRlKClcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVXcml0ZU5UICgpIHtcbiAgaWYgKCh0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9VUERBVElORykgPT09IDApIHtcbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gV1JJVEVfTk9UX05FWFRfVElDS1xuICAgIHRoaXMudXBkYXRlKClcbiAgfVxufVxuXG5mdW5jdGlvbiB0aWNrRHJhaW5zIChkcmFpbnMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcmFpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBkcmFpbnMud3JpdGVzIGFyZSBtb25vdG9uaWMsIHNvIGlmIG9uZSBpcyAwIGl0cyBhbHdheXMgdGhlIGZpcnN0IG9uZVxuICAgIGlmICgtLWRyYWluc1tpXS53cml0ZXMgPT09IDApIHtcbiAgICAgIGRyYWlucy5zaGlmdCgpLnJlc29sdmUodHJ1ZSlcbiAgICAgIGktLVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlck9wZW4gKGVycikge1xuICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gIGlmIChlcnIpIHN0cmVhbS5kZXN0cm95KGVycilcblxuICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBERVNUUk9ZSU5HKSA9PT0gMCkge1xuICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfUFJJTUFSWV9TVEFUVVMpID09PSAwKSBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IFJFQURfUFJJTUFSWVxuICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX1BSSU1BUllfU1RBVFVTKSA9PT0gMCkgc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBXUklURV9QUklNQVJZXG4gICAgc3RyZWFtLmVtaXQoJ29wZW4nKVxuICB9XG5cbiAgc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBOT1RfQUNUSVZFXG5cbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZSAhPT0gbnVsbCkge1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS51cGRhdGVDYWxsYmFjaygpXG4gIH1cblxuICBpZiAoc3RyZWFtLl9yZWFkYWJsZVN0YXRlICE9PSBudWxsKSB7XG4gICAgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLnVwZGF0ZUNhbGxiYWNrKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybSAoZXJyLCBkYXRhKSB7XG4gIGlmIChkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YSAhPT0gbnVsbCkgdGhpcy5wdXNoKGRhdGEpXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuYWZ0ZXJXcml0ZShlcnIpXG59XG5cbmZ1bmN0aW9uIG5ld0xpc3RlbmVyIChuYW1lKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlICE9PSBudWxsKSB7XG4gICAgaWYgKG5hbWUgPT09ICdkYXRhJykge1xuICAgICAgdGhpcy5fZHVwbGV4U3RhdGUgfD0gKFJFQURfRU1JVF9EQVRBIHwgUkVBRF9SRVNVTUVEX1JFQURfQUhFQUQpXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgIHRoaXMuX2R1cGxleFN0YXRlIHw9IFJFQURfRU1JVF9SRUFEQUJMRVxuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgIT09IG51bGwpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2RyYWluJykge1xuICAgICAgdGhpcy5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfRU1JVF9EUkFJTlxuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFN0cmVhbSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5fZHVwbGV4U3RhdGUgPSAwXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG51bGxcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlID0gbnVsbFxuXG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIGlmIChvcHRzLm9wZW4pIHRoaXMuX29wZW4gPSBvcHRzLm9wZW5cbiAgICAgIGlmIChvcHRzLmRlc3Ryb3kpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRzLmRlc3Ryb3lcbiAgICAgIGlmIChvcHRzLnByZWRlc3Ryb3kpIHRoaXMuX3ByZWRlc3Ryb3kgPSBvcHRzLnByZWRlc3Ryb3lcbiAgICAgIGlmIChvcHRzLnNpZ25hbCkge1xuICAgICAgICBvcHRzLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0LmJpbmQodGhpcykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vbignbmV3TGlzdGVuZXInLCBuZXdMaXN0ZW5lcilcbiAgfVxuXG4gIF9vcGVuIChjYikge1xuICAgIGNiKG51bGwpXG4gIH1cblxuICBfZGVzdHJveSAoY2IpIHtcbiAgICBjYihudWxsKVxuICB9XG5cbiAgX3ByZWRlc3Ryb3kgKCkge1xuICAgIC8vIGRvZXMgbm90aGluZ1xuICB9XG5cbiAgZ2V0IHJlYWRhYmxlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAhPT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWRcbiAgfVxuXG4gIGdldCB3cml0YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgIT09IG51bGwgPyB0cnVlIDogdW5kZWZpbmVkXG4gIH1cblxuICBnZXQgZGVzdHJveWVkICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2R1cGxleFN0YXRlICYgREVTVFJPWUVEKSAhPT0gMFxuICB9XG5cbiAgZ2V0IGRlc3Ryb3lpbmcgKCkge1xuICAgIHJldHVybiAodGhpcy5fZHVwbGV4U3RhdGUgJiBERVNUUk9ZX1NUQVRVUykgIT09IDBcbiAgfVxuXG4gIGRlc3Ryb3kgKGVycikge1xuICAgIGlmICgodGhpcy5fZHVwbGV4U3RhdGUgJiBERVNUUk9ZX1NUQVRVUykgPT09IDApIHtcbiAgICAgIGlmICghZXJyKSBlcnIgPSBTVFJFQU1fREVTVFJPWUVEXG4gICAgICB0aGlzLl9kdXBsZXhTdGF0ZSA9ICh0aGlzLl9kdXBsZXhTdGF0ZSB8IERFU1RST1lJTkcpICYgTk9OX1BSSU1BUllcblxuICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrID0gMFxuICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVycm9yID0gZXJyXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcmsgPSAwXG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3IgPSBlcnJcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZHVwbGV4U3RhdGUgfD0gUFJFREVTVFJPWUlOR1xuICAgICAgdGhpcy5fcHJlZGVzdHJveSgpXG4gICAgICB0aGlzLl9kdXBsZXhTdGF0ZSAmPSBOT1RfUFJFREVTVFJPWUlOR1xuXG4gICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSAhPT0gbnVsbCkgdGhpcy5fcmVhZGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSAhPT0gbnVsbCkgdGhpcy5fd3JpdGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFJlYWRhYmxlIGV4dGVuZHMgU3RyZWFtIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuXG4gICAgdGhpcy5fZHVwbGV4U3RhdGUgfD0gT1BFTklORyB8IFdSSVRFX0RPTkUgfCBSRUFEX1JFQURfQUhFQURcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUodGhpcywgb3B0cylcblxuICAgIGlmIChvcHRzKSB7XG4gICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkQWhlYWQgPT09IGZhbHNlKSB0aGlzLl9kdXBsZXhTdGF0ZSAmPSBSRUFEX05PX1JFQURfQUhFQURcbiAgICAgIGlmIChvcHRzLnJlYWQpIHRoaXMuX3JlYWQgPSBvcHRzLnJlYWRcbiAgICAgIGlmIChvcHRzLmVhZ2VyT3BlbikgdGhpcy5fcmVhZGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgICBpZiAob3B0cy5lbmNvZGluZykgdGhpcy5zZXRFbmNvZGluZyhvcHRzLmVuY29kaW5nKVxuICAgIH1cbiAgfVxuXG4gIHNldEVuY29kaW5nIChlbmNvZGluZykge1xuICAgIGNvbnN0IGRlYyA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZylcbiAgICBjb25zdCBtYXAgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLm1hcCB8fCBlY2hvXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5tYXAgPSBtYXBPclNraXBcbiAgICByZXR1cm4gdGhpc1xuXG4gICAgZnVuY3Rpb24gbWFwT3JTa2lwIChkYXRhKSB7XG4gICAgICBjb25zdCBuZXh0ID0gZGVjLnB1c2goZGF0YSlcbiAgICAgIHJldHVybiBuZXh0ID09PSAnJyAmJiAoZGF0YS5ieXRlTGVuZ3RoICE9PSAwIHx8IGRlYy5yZW1haW5pbmcgPiAwKSA/IG51bGwgOiBtYXAobmV4dClcbiAgICB9XG4gIH1cblxuICBfcmVhZCAoY2IpIHtcbiAgICBjYihudWxsKVxuICB9XG5cbiAgcGlwZSAoZGVzdCwgY2IpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnBpcGUoZGVzdCwgY2IpXG4gICAgcmV0dXJuIGRlc3RcbiAgfVxuXG4gIHJlYWQgKCkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWQoKVxuICB9XG5cbiAgcHVzaCAoZGF0YSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLnB1c2goZGF0YSlcbiAgfVxuXG4gIHVuc2hpZnQgKGRhdGEpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS51bnNoaWZ0KGRhdGEpXG4gIH1cblxuICByZXN1bWUgKCkge1xuICAgIHRoaXMuX2R1cGxleFN0YXRlIHw9IFJFQURfUkVTVU1FRF9SRUFEX0FIRUFEXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHBhdXNlICgpIHtcbiAgICB0aGlzLl9kdXBsZXhTdGF0ZSAmPSAodGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkQWhlYWQgPT09IGZhbHNlID8gUkVBRF9QQVVTRURfTk9fUkVBRF9BSEVBRCA6IFJFQURfUEFVU0VEKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGF0aWMgX2Zyb21Bc3luY0l0ZXJhdG9yIChpdGUsIG9wdHMpIHtcbiAgICBsZXQgZGVzdHJveVxuXG4gICAgY29uc3QgcnMgPSBuZXcgUmVhZGFibGUoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIHJlYWQgKGNiKSB7XG4gICAgICAgIGl0ZS5uZXh0KCkudGhlbihwdXNoKS50aGVuKGNiLmJpbmQobnVsbCwgbnVsbCkpLmNhdGNoKGNiKVxuICAgICAgfSxcbiAgICAgIHByZWRlc3Ryb3kgKCkge1xuICAgICAgICBkZXN0cm95ID0gaXRlLnJldHVybigpXG4gICAgICB9LFxuICAgICAgZGVzdHJveSAoY2IpIHtcbiAgICAgICAgaWYgKCFkZXN0cm95KSByZXR1cm4gY2IobnVsbClcbiAgICAgICAgZGVzdHJveS50aGVuKGNiLmJpbmQobnVsbCwgbnVsbCkpLmNhdGNoKGNiKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gcnNcblxuICAgIGZ1bmN0aW9uIHB1c2ggKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmRvbmUpIHJzLnB1c2gobnVsbClcbiAgICAgIGVsc2UgcnMucHVzaChkYXRhLnZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBmcm9tIChkYXRhLCBvcHRzKSB7XG4gICAgaWYgKGlzUmVhZFN0cmVhbXgoZGF0YSkpIHJldHVybiBkYXRhXG4gICAgaWYgKGRhdGFbYXN5bmNJdGVyYXRvcl0pIHJldHVybiB0aGlzLl9mcm9tQXN5bmNJdGVyYXRvcihkYXRhW2FzeW5jSXRlcmF0b3JdKCksIG9wdHMpXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSBkYXRhID0gZGF0YSA9PT0gdW5kZWZpbmVkID8gW10gOiBbZGF0YV1cblxuICAgIGxldCBpID0gMFxuICAgIHJldHVybiBuZXcgUmVhZGFibGUoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIHJlYWQgKGNiKSB7XG4gICAgICAgIHRoaXMucHVzaChpID09PSBkYXRhLmxlbmd0aCA/IG51bGwgOiBkYXRhW2krK10pXG4gICAgICAgIGNiKG51bGwpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHN0YXRpYyBpc0JhY2twcmVzc3VyZWQgKHJzKSB7XG4gICAgcmV0dXJuIChycy5fZHVwbGV4U3RhdGUgJiBSRUFEX0JBQ0tQUkVTU1VSRV9TVEFUVVMpICE9PSAwIHx8IHJzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcmVkID49IHJzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcmtcbiAgfVxuXG4gIHN0YXRpYyBpc1BhdXNlZCAocnMpIHtcbiAgICByZXR1cm4gKHJzLl9kdXBsZXhTdGF0ZSAmIFJFQURfUkVTVU1FRCkgPT09IDBcbiAgfVxuXG4gIFthc3luY0l0ZXJhdG9yXSAoKSB7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpc1xuXG4gICAgbGV0IGVycm9yID0gbnVsbFxuICAgIGxldCBwcm9taXNlUmVzb2x2ZSA9IG51bGxcbiAgICBsZXQgcHJvbWlzZVJlamVjdCA9IG51bGxcblxuICAgIHRoaXMub24oJ2Vycm9yJywgKGVycikgPT4geyBlcnJvciA9IGVyciB9KVxuICAgIHRoaXMub24oJ3JlYWRhYmxlJywgb25yZWFkYWJsZSlcbiAgICB0aGlzLm9uKCdjbG9zZScsIG9uY2xvc2UpXG5cbiAgICByZXR1cm4ge1xuICAgICAgW2FzeW5jSXRlcmF0b3JdICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICBuZXh0ICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHN0cmVhbS5yZWFkKClcbiAgICAgICAgICBpZiAoZGF0YSAhPT0gbnVsbCkgb25kYXRhKGRhdGEpXG4gICAgICAgICAgZWxzZSBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBERVNUUk9ZRUQpICE9PSAwKSBvbmRhdGEobnVsbClcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICByZXR1cm4gKCkge1xuICAgICAgICByZXR1cm4gZGVzdHJveShudWxsKVxuICAgICAgfSxcbiAgICAgIHRocm93IChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGRlc3Ryb3koZXJyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ucmVhZGFibGUgKCkge1xuICAgICAgaWYgKHByb21pc2VSZXNvbHZlICE9PSBudWxsKSBvbmRhdGEoc3RyZWFtLnJlYWQoKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcbiAgICAgIGlmIChwcm9taXNlUmVzb2x2ZSAhPT0gbnVsbCkgb25kYXRhKG51bGwpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25kYXRhIChkYXRhKSB7XG4gICAgICBpZiAocHJvbWlzZVJlamVjdCA9PT0gbnVsbCkgcmV0dXJuXG4gICAgICBpZiAoZXJyb3IpIHByb21pc2VSZWplY3QoZXJyb3IpXG4gICAgICBlbHNlIGlmIChkYXRhID09PSBudWxsICYmIChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9ET05FKSA9PT0gMCkgcHJvbWlzZVJlamVjdChTVFJFQU1fREVTVFJPWUVEKVxuICAgICAgZWxzZSBwcm9taXNlUmVzb2x2ZSh7IHZhbHVlOiBkYXRhLCBkb25lOiBkYXRhID09PSBudWxsIH0pXG4gICAgICBwcm9taXNlUmVqZWN0ID0gcHJvbWlzZVJlc29sdmUgPSBudWxsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVzdHJveSAoZXJyKSB7XG4gICAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIERFU1RST1lFRCkgcmV0dXJuIHJlc29sdmUoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pXG4gICAgICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZXJyKSByZWplY3QoZXJyKVxuICAgICAgICAgIGVsc2UgcmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFdyaXRhYmxlIGV4dGVuZHMgU3RyZWFtIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuXG4gICAgdGhpcy5fZHVwbGV4U3RhdGUgfD0gT1BFTklORyB8IFJFQURfRE9ORVxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZSh0aGlzLCBvcHRzKVxuXG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIGlmIChvcHRzLndyaXRldikgdGhpcy5fd3JpdGV2ID0gb3B0cy53cml0ZXZcbiAgICAgIGlmIChvcHRzLndyaXRlKSB0aGlzLl93cml0ZSA9IG9wdHMud3JpdGVcbiAgICAgIGlmIChvcHRzLmZpbmFsKSB0aGlzLl9maW5hbCA9IG9wdHMuZmluYWxcbiAgICAgIGlmIChvcHRzLmVhZ2VyT3BlbikgdGhpcy5fd3JpdGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgfVxuICB9XG5cbiAgY29yayAoKSB7XG4gICAgdGhpcy5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfQ09SS0VEXG4gIH1cblxuICB1bmNvcmsgKCkge1xuICAgIHRoaXMuX2R1cGxleFN0YXRlICY9IFdSSVRFX05PVF9DT1JLRURcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgfVxuXG4gIF93cml0ZXYgKGJhdGNoLCBjYikge1xuICAgIGNiKG51bGwpXG4gIH1cblxuICBfd3JpdGUgKGRhdGEsIGNiKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5hdXRvQmF0Y2goZGF0YSwgY2IpXG4gIH1cblxuICBfZmluYWwgKGNiKSB7XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIHN0YXRpYyBpc0JhY2twcmVzc3VyZWQgKHdzKSB7XG4gICAgcmV0dXJuICh3cy5fZHVwbGV4U3RhdGUgJiBXUklURV9CQUNLUFJFU1NVUkVfU1RBVFVTKSAhPT0gMFxuICB9XG5cbiAgc3RhdGljIGRyYWluZWQgKHdzKSB7XG4gICAgaWYgKHdzLmRlc3Ryb3llZCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSlcbiAgICBjb25zdCBzdGF0ZSA9IHdzLl93cml0YWJsZVN0YXRlXG4gICAgY29uc3QgcGVuZGluZyA9IChpc1dyaXRldih3cykgPyBNYXRoLm1pbigxLCBzdGF0ZS5xdWV1ZS5sZW5ndGgpIDogc3RhdGUucXVldWUubGVuZ3RoKVxuICAgIGNvbnN0IHdyaXRlcyA9IHBlbmRpbmcgKyAoKHdzLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX1dSSVRJTkcpID8gMSA6IDApXG4gICAgaWYgKHdyaXRlcyA9PT0gMCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKVxuICAgIGlmIChzdGF0ZS5kcmFpbnMgPT09IG51bGwpIHN0YXRlLmRyYWlucyA9IFtdXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBzdGF0ZS5kcmFpbnMucHVzaCh7IHdyaXRlcywgcmVzb2x2ZSB9KVxuICAgIH0pXG4gIH1cblxuICB3cml0ZSAoZGF0YSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLnB1c2goZGF0YSlcbiAgfVxuXG4gIGVuZCAoZGF0YSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kKGRhdGEpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5jbGFzcyBEdXBsZXggZXh0ZW5kcyBSZWFkYWJsZSB7IC8vIGFuZCBXcml0YWJsZVxuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG5cbiAgICB0aGlzLl9kdXBsZXhTdGF0ZSA9IE9QRU5JTkcgfCAodGhpcy5fZHVwbGV4U3RhdGUgJiBSRUFEX1JFQURfQUhFQUQpXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKHRoaXMsIG9wdHMpXG5cbiAgICBpZiAob3B0cykge1xuICAgICAgaWYgKG9wdHMud3JpdGV2KSB0aGlzLl93cml0ZXYgPSBvcHRzLndyaXRldlxuICAgICAgaWYgKG9wdHMud3JpdGUpIHRoaXMuX3dyaXRlID0gb3B0cy53cml0ZVxuICAgICAgaWYgKG9wdHMuZmluYWwpIHRoaXMuX2ZpbmFsID0gb3B0cy5maW5hbFxuICAgIH1cbiAgfVxuXG4gIGNvcmsgKCkge1xuICAgIHRoaXMuX2R1cGxleFN0YXRlIHw9IFdSSVRFX0NPUktFRFxuICB9XG5cbiAgdW5jb3JrICgpIHtcbiAgICB0aGlzLl9kdXBsZXhTdGF0ZSAmPSBXUklURV9OT1RfQ09SS0VEXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gIH1cblxuICBfd3JpdGV2IChiYXRjaCwgY2IpIHtcbiAgICBjYihudWxsKVxuICB9XG5cbiAgX3dyaXRlIChkYXRhLCBjYikge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuYXV0b0JhdGNoKGRhdGEsIGNiKVxuICB9XG5cbiAgX2ZpbmFsIChjYikge1xuICAgIGNiKG51bGwpXG4gIH1cblxuICB3cml0ZSAoZGF0YSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLnB1c2goZGF0YSlcbiAgfVxuXG4gIGVuZCAoZGF0YSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kKGRhdGEpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5jbGFzcyBUcmFuc2Zvcm0gZXh0ZW5kcyBEdXBsZXgge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG4gICAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcylcblxuICAgIGlmIChvcHRzKSB7XG4gICAgICBpZiAob3B0cy50cmFuc2Zvcm0pIHRoaXMuX3RyYW5zZm9ybSA9IG9wdHMudHJhbnNmb3JtXG4gICAgICBpZiAob3B0cy5mbHVzaCkgdGhpcy5fZmx1c2ggPSBvcHRzLmZsdXNoXG4gICAgfVxuICB9XG5cbiAgX3dyaXRlIChkYXRhLCBjYikge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcmVkID49IHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtU3RhdGUuZGF0YSA9IGRhdGFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtKGRhdGEsIHRoaXMuX3RyYW5zZm9ybVN0YXRlLmFmdGVyVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxuXG4gIF9yZWFkIChjYikge1xuICAgIGlmICh0aGlzLl90cmFuc2Zvcm1TdGF0ZS5kYXRhICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5fdHJhbnNmb3JtU3RhdGUuZGF0YVxuICAgICAgdGhpcy5fdHJhbnNmb3JtU3RhdGUuZGF0YSA9IG51bGxcbiAgICAgIGNiKG51bGwpXG4gICAgICB0aGlzLl90cmFuc2Zvcm0oZGF0YSwgdGhpcy5fdHJhbnNmb3JtU3RhdGUuYWZ0ZXJUcmFuc2Zvcm0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKG51bGwpXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoZXJyKSB7XG4gICAgc3VwZXIuZGVzdHJveShlcnIpXG4gICAgaWYgKHRoaXMuX3RyYW5zZm9ybVN0YXRlLmRhdGEgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybVN0YXRlLmRhdGEgPSBudWxsXG4gICAgICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5hZnRlclRyYW5zZm9ybSgpXG4gICAgfVxuICB9XG5cbiAgX3RyYW5zZm9ybSAoZGF0YSwgY2IpIHtcbiAgICBjYihudWxsLCBkYXRhKVxuICB9XG5cbiAgX2ZsdXNoIChjYikge1xuICAgIGNiKG51bGwpXG4gIH1cblxuICBfZmluYWwgKGNiKSB7XG4gICAgdGhpcy5fdHJhbnNmb3JtU3RhdGUuYWZ0ZXJGaW5hbCA9IGNiXG4gICAgdGhpcy5fZmx1c2godHJhbnNmb3JtQWZ0ZXJGbHVzaC5iaW5kKHRoaXMpKVxuICB9XG59XG5cbmNsYXNzIFBhc3NUaHJvdWdoIGV4dGVuZHMgVHJhbnNmb3JtIHt9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUFmdGVyRmx1c2ggKGVyciwgZGF0YSkge1xuICBjb25zdCBjYiA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlLmFmdGVyRmluYWxcbiAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSB0aGlzLnB1c2goZGF0YSlcbiAgdGhpcy5wdXNoKG51bGwpXG4gIGNiKG51bGwpXG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lUHJvbWlzZSAoLi4uc3RyZWFtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJldHVybiBwaXBlbGluZSguLi5zdHJlYW1zLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgIHJlc29sdmUoKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lIChzdHJlYW0sIC4uLnN0cmVhbXMpIHtcbiAgY29uc3QgYWxsID0gQXJyYXkuaXNBcnJheShzdHJlYW0pID8gWy4uLnN0cmVhbSwgLi4uc3RyZWFtc10gOiBbc3RyZWFtLCAuLi5zdHJlYW1zXVxuICBjb25zdCBkb25lID0gKGFsbC5sZW5ndGggJiYgdHlwZW9mIGFsbFthbGwubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpID8gYWxsLnBvcCgpIDogbnVsbFxuXG4gIGlmIChhbGwubGVuZ3RoIDwgMikgdGhyb3cgbmV3IEVycm9yKCdQaXBlbGluZSByZXF1aXJlcyBhdCBsZWFzdCAyIHN0cmVhbXMnKVxuXG4gIGxldCBzcmMgPSBhbGxbMF1cbiAgbGV0IGRlc3QgPSBudWxsXG4gIGxldCBlcnJvciA9IG51bGxcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgIGRlc3QgPSBhbGxbaV1cblxuICAgIGlmIChpc1N0cmVhbXgoc3JjKSkge1xuICAgICAgc3JjLnBpcGUoZGVzdCwgb25lcnJvcilcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JIYW5kbGUoc3JjLCB0cnVlLCBpID4gMSwgb25lcnJvcilcbiAgICAgIHNyYy5waXBlKGRlc3QpXG4gICAgfVxuXG4gICAgc3JjID0gZGVzdFxuICB9XG5cbiAgaWYgKGRvbmUpIHtcbiAgICBsZXQgZmluID0gZmFsc2VcblxuICAgIGNvbnN0IGF1dG9EZXN0cm95ID0gaXNTdHJlYW14KGRlc3QpIHx8ICEhKGRlc3QuX3dyaXRhYmxlU3RhdGUgJiYgZGVzdC5fd3JpdGFibGVTdGF0ZS5hdXRvRGVzdHJveSlcblxuICAgIGRlc3Qub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgaWYgKGVycm9yID09PSBudWxsKSBlcnJvciA9IGVyclxuICAgIH0pXG5cbiAgICBkZXN0Lm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICBmaW4gPSB0cnVlXG4gICAgICBpZiAoIWF1dG9EZXN0cm95KSBkb25lKGVycm9yKVxuICAgIH0pXG5cbiAgICBpZiAoYXV0b0Rlc3Ryb3kpIHtcbiAgICAgIGRlc3Qub24oJ2Nsb3NlJywgKCkgPT4gZG9uZShlcnJvciB8fCAoZmluID8gbnVsbCA6IFBSRU1BVFVSRV9DTE9TRSkpKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXN0XG5cbiAgZnVuY3Rpb24gZXJyb3JIYW5kbGUgKHMsIHJkLCB3ciwgb25lcnJvcikge1xuICAgIHMub24oJ2Vycm9yJywgb25lcnJvcilcbiAgICBzLm9uKCdjbG9zZScsIG9uY2xvc2UpXG5cbiAgICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcbiAgICAgIGlmIChyZCAmJiBzLl9yZWFkYWJsZVN0YXRlICYmICFzLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSByZXR1cm4gb25lcnJvcihQUkVNQVRVUkVfQ0xPU0UpXG4gICAgICBpZiAod3IgJiYgcy5fd3JpdGFibGVTdGF0ZSAmJiAhcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuIG9uZXJyb3IoUFJFTUFUVVJFX0NMT1NFKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IgKGVycikge1xuICAgIGlmICghZXJyIHx8IGVycm9yKSByZXR1cm5cbiAgICBlcnJvciA9IGVyclxuXG4gICAgZm9yIChjb25zdCBzIG9mIGFsbCkge1xuICAgICAgcy5kZXN0cm95KGVycilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZWNobyAocykge1xuICByZXR1cm4gc1xufVxuXG5mdW5jdGlvbiBpc1N0cmVhbSAoc3RyZWFtKSB7XG4gIHJldHVybiAhIXN0cmVhbS5fcmVhZGFibGVTdGF0ZSB8fCAhIXN0cmVhbS5fd3JpdGFibGVTdGF0ZVxufVxuXG5mdW5jdGlvbiBpc1N0cmVhbXggKHN0cmVhbSkge1xuICByZXR1cm4gdHlwZW9mIHN0cmVhbS5fZHVwbGV4U3RhdGUgPT09ICdudW1iZXInICYmIGlzU3RyZWFtKHN0cmVhbSlcbn1cblxuZnVuY3Rpb24gaXNFbmRlZCAoc3RyZWFtKSB7XG4gIHJldHVybiAhIXN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kZWRcbn1cblxuZnVuY3Rpb24gaXNGaW5pc2hlZCAoc3RyZWFtKSB7XG4gIHJldHVybiAhIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSAmJiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZW5kZWRcbn1cblxuZnVuY3Rpb24gZ2V0U3RyZWFtRXJyb3IgKHN0cmVhbSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGVyciA9IChzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVycm9yKSB8fCAoc3RyZWFtLl93cml0YWJsZVN0YXRlICYmIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvcilcblxuICAvLyBhdm9pZCBpbXBsaWNpdCBlcnJvcnMgYnkgZGVmYXVsdFxuICByZXR1cm4gKCFvcHRzLmFsbCAmJiBlcnIgPT09IFNUUkVBTV9ERVNUUk9ZRUQpID8gbnVsbCA6IGVyclxufVxuXG5mdW5jdGlvbiBpc1JlYWRTdHJlYW14IChzdHJlYW0pIHtcbiAgcmV0dXJuIGlzU3RyZWFteChzdHJlYW0pICYmIHN0cmVhbS5yZWFkYWJsZVxufVxuXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkgKGRhdGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhICE9PSBudWxsICYmIHR5cGVvZiBkYXRhLmJ5dGVMZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRCeXRlTGVuZ3RoIChkYXRhKSB7XG4gIHJldHVybiBpc1R5cGVkQXJyYXkoZGF0YSkgPyBkYXRhLmJ5dGVMZW5ndGggOiAxMDI0XG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gYWJvcnQgKCkge1xuICB0aGlzLmRlc3Ryb3kobmV3IEVycm9yKCdTdHJlYW0gYWJvcnRlZC4nKSlcbn1cblxuZnVuY3Rpb24gaXNXcml0ZXYgKHMpIHtcbiAgcmV0dXJuIHMuX3dyaXRldiAhPT0gV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgJiYgcy5fd3JpdGV2ICE9PSBEdXBsZXgucHJvdG90eXBlLl93cml0ZXZcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBpcGVsaW5lLFxuICBwaXBlbGluZVByb21pc2UsXG4gIGlzU3RyZWFtLFxuICBpc1N0cmVhbXgsXG4gIGlzRW5kZWQsXG4gIGlzRmluaXNoZWQsXG4gIGdldFN0cmVhbUVycm9yLFxuICBTdHJlYW0sXG4gIFdyaXRhYmxlLFxuICBSZWFkYWJsZSxcbiAgRHVwbGV4LFxuICBUcmFuc2Zvcm0sXG4gIC8vIEV4cG9ydCBQYXNzVGhyb3VnaCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIE5vZGUuanMgY29yZSdzIHN0cmVhbSBtb2R1bGVcbiAgUGFzc1Rocm91Z2hcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/streamx/index.js\n");

/***/ })

};
;