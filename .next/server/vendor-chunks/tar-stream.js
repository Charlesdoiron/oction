/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tar-stream";
exports.ids = ["vendor-chunks/tar-stream"];
exports.modules = {

/***/ "(rsc)/./node_modules/tar-stream/constants.js":
/*!**********************************************!*\
  !*** ./node_modules/tar-stream/constants.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const constants = { // just for envs without fs\n  S_IFMT: 61440,\n  S_IFDIR: 16384,\n  S_IFCHR: 8192,\n  S_IFBLK: 24576,\n  S_IFIFO: 4096,\n  S_IFLNK: 40960\n}\n\ntry {\n  module.exports = (__webpack_require__(/*! fs */ \"fs\").constants) || constants\n} catch {\n  module.exports = constants\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLCtDQUF1QjtBQUMxQyxFQUFFO0FBQ0Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2F1Y3Rpb24tc2NyYXBwZXIvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9jb25zdGFudHMuanM/NmU2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb25zdGFudHMgPSB7IC8vIGp1c3QgZm9yIGVudnMgd2l0aG91dCBmc1xuICBTX0lGTVQ6IDYxNDQwLFxuICBTX0lGRElSOiAxNjM4NCxcbiAgU19JRkNIUjogODE5MixcbiAgU19JRkJMSzogMjQ1NzYsXG4gIFNfSUZJRk86IDQwOTYsXG4gIFNfSUZMTks6IDQwOTYwXG59XG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZnMnKS5jb25zdGFudHMgfHwgY29uc3RhbnRzXG59IGNhdGNoIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudHNcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar-stream/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar-stream/extract.js":
/*!********************************************!*\
  !*** ./node_modules/tar-stream/extract.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Writable, Readable, getStreamError } = __webpack_require__(/*! streamx */ \"(rsc)/./node_modules/streamx/index.js\")\nconst FIFO = __webpack_require__(/*! fast-fifo */ \"(rsc)/./node_modules/fast-fifo/index.js\")\nconst b4a = __webpack_require__(/*! b4a */ \"(rsc)/./node_modules/b4a/index.js\")\nconst headers = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/tar-stream/headers.js\")\n\nconst EMPTY = b4a.alloc(0)\n\nclass BufferList {\n  constructor () {\n    this.buffered = 0\n    this.shifted = 0\n    this.queue = new FIFO()\n\n    this._offset = 0\n  }\n\n  push (buffer) {\n    this.buffered += buffer.byteLength\n    this.queue.push(buffer)\n  }\n\n  shiftFirst (size) {\n    return this._buffered === 0 ? null : this._next(size)\n  }\n\n  shift (size) {\n    if (size > this.buffered) return null\n    if (size === 0) return EMPTY\n\n    let chunk = this._next(size)\n\n    if (size === chunk.byteLength) return chunk // likely case\n\n    const chunks = [chunk]\n\n    while ((size -= chunk.byteLength) > 0) {\n      chunk = this._next(size)\n      chunks.push(chunk)\n    }\n\n    return b4a.concat(chunks)\n  }\n\n  _next (size) {\n    const buf = this.queue.peek()\n    const rem = buf.byteLength - this._offset\n\n    if (size >= rem) {\n      const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf\n      this.queue.shift()\n      this._offset = 0\n      this.buffered -= rem\n      this.shifted += rem\n      return sub\n    }\n\n    this.buffered -= size\n    this.shifted += size\n\n    return buf.subarray(this._offset, (this._offset += size))\n  }\n}\n\nclass Source extends Readable {\n  constructor (self, header, offset) {\n    super()\n\n    this.header = header\n    this.offset = offset\n\n    this._parent = self\n  }\n\n  _read (cb) {\n    if (this.header.size === 0) {\n      this.push(null)\n    }\n    if (this._parent._stream === this) {\n      this._parent._update()\n    }\n    cb(null)\n  }\n\n  _predestroy () {\n    this._parent.destroy(getStreamError(this))\n  }\n\n  _detach () {\n    if (this._parent._stream === this) {\n      this._parent._stream = null\n      this._parent._missing = overflow(this.header.size)\n      this._parent._update()\n    }\n  }\n\n  _destroy (cb) {\n    this._detach()\n    cb(null)\n  }\n}\n\nclass Extract extends Writable {\n  constructor (opts) {\n    super(opts)\n\n    if (!opts) opts = {}\n\n    this._buffer = new BufferList()\n    this._offset = 0\n    this._header = null\n    this._stream = null\n    this._missing = 0\n    this._longHeader = false\n    this._callback = noop\n    this._locked = false\n    this._finished = false\n    this._pax = null\n    this._paxGlobal = null\n    this._gnuLongPath = null\n    this._gnuLongLinkPath = null\n    this._filenameEncoding = opts.filenameEncoding || 'utf-8'\n    this._allowUnknownFormat = !!opts.allowUnknownFormat\n    this._unlockBound = this._unlock.bind(this)\n  }\n\n  _unlock (err) {\n    this._locked = false\n\n    if (err) {\n      this.destroy(err)\n      this._continueWrite(err)\n      return\n    }\n\n    this._update()\n  }\n\n  _consumeHeader () {\n    if (this._locked) return false\n\n    this._offset = this._buffer.shifted\n\n    try {\n      this._header = headers.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat)\n    } catch (err) {\n      this._continueWrite(err)\n      return false\n    }\n\n    if (!this._header) return true\n\n    switch (this._header.type) {\n      case 'gnu-long-path':\n      case 'gnu-long-link-path':\n      case 'pax-global-header':\n      case 'pax-header':\n        this._longHeader = true\n        this._missing = this._header.size\n        return true\n    }\n\n    this._locked = true\n    this._applyLongHeaders()\n\n    if (this._header.size === 0 || this._header.type === 'directory') {\n      this.emit('entry', this._header, this._createStream(), this._unlockBound)\n      return true\n    }\n\n    this._stream = this._createStream()\n    this._missing = this._header.size\n\n    this.emit('entry', this._header, this._stream, this._unlockBound)\n    return true\n  }\n\n  _applyLongHeaders () {\n    if (this._gnuLongPath) {\n      this._header.name = this._gnuLongPath\n      this._gnuLongPath = null\n    }\n\n    if (this._gnuLongLinkPath) {\n      this._header.linkname = this._gnuLongLinkPath\n      this._gnuLongLinkPath = null\n    }\n\n    if (this._pax) {\n      if (this._pax.path) this._header.name = this._pax.path\n      if (this._pax.linkpath) this._header.linkname = this._pax.linkpath\n      if (this._pax.size) this._header.size = parseInt(this._pax.size, 10)\n      this._header.pax = this._pax\n      this._pax = null\n    }\n  }\n\n  _decodeLongHeader (buf) {\n    switch (this._header.type) {\n      case 'gnu-long-path':\n        this._gnuLongPath = headers.decodeLongPath(buf, this._filenameEncoding)\n        break\n      case 'gnu-long-link-path':\n        this._gnuLongLinkPath = headers.decodeLongPath(buf, this._filenameEncoding)\n        break\n      case 'pax-global-header':\n        this._paxGlobal = headers.decodePax(buf)\n        break\n      case 'pax-header':\n        this._pax = this._paxGlobal === null\n          ? headers.decodePax(buf)\n          : Object.assign({}, this._paxGlobal, headers.decodePax(buf))\n        break\n    }\n  }\n\n  _consumeLongHeader () {\n    this._longHeader = false\n    this._missing = overflow(this._header.size)\n\n    const buf = this._buffer.shift(this._header.size)\n\n    try {\n      this._decodeLongHeader(buf)\n    } catch (err) {\n      this._continueWrite(err)\n      return false\n    }\n\n    return true\n  }\n\n  _consumeStream () {\n    const buf = this._buffer.shiftFirst(this._missing)\n    if (buf === null) return false\n\n    this._missing -= buf.byteLength\n    const drained = this._stream.push(buf)\n\n    if (this._missing === 0) {\n      this._stream.push(null)\n      if (drained) this._stream._detach()\n      return drained && this._locked === false\n    }\n\n    return drained\n  }\n\n  _createStream () {\n    return new Source(this, this._header, this._offset)\n  }\n\n  _update () {\n    while (this._buffer.buffered > 0 && !this.destroying) {\n      if (this._missing > 0) {\n        if (this._stream !== null) {\n          if (this._consumeStream() === false) return\n          continue\n        }\n\n        if (this._longHeader === true) {\n          if (this._missing > this._buffer.buffered) break\n          if (this._consumeLongHeader() === false) return false\n          continue\n        }\n\n        const ignore = this._buffer.shiftFirst(this._missing)\n        if (ignore !== null) this._missing -= ignore.byteLength\n        continue\n      }\n\n      if (this._buffer.buffered < 512) break\n      if (this._stream !== null || this._consumeHeader() === false) return\n    }\n\n    this._continueWrite(null)\n  }\n\n  _continueWrite (err) {\n    const cb = this._callback\n    this._callback = noop\n    cb(err)\n  }\n\n  _write (data, cb) {\n    this._callback = cb\n    this._buffer.push(data)\n    this._update()\n  }\n\n  _final (cb) {\n    this._finished = this._missing === 0 && this._buffer.buffered === 0\n    cb(this._finished ? null : new Error('Unexpected end of data'))\n  }\n\n  _predestroy () {\n    this._continueWrite(null)\n  }\n\n  _destroy (cb) {\n    if (this._stream) this._stream.destroy(getStreamError(this))\n    cb(null)\n  }\n\n  [Symbol.asyncIterator] () {\n    let error = null\n\n    let promiseResolve = null\n    let promiseReject = null\n\n    let entryStream = null\n    let entryCallback = null\n\n    const extract = this\n\n    this.on('entry', onentry)\n    this.on('error', (err) => { error = err })\n    this.on('close', onclose)\n\n    return {\n      [Symbol.asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(onnext)\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function consumeCallback (err) {\n      if (!entryCallback) return\n      const cb = entryCallback\n      entryCallback = null\n      cb(err)\n    }\n\n    function onnext (resolve, reject) {\n      if (error) {\n        return reject(error)\n      }\n\n      if (entryStream) {\n        resolve({ value: entryStream, done: false })\n        entryStream = null\n        return\n      }\n\n      promiseResolve = resolve\n      promiseReject = reject\n\n      consumeCallback(null)\n\n      if (extract._finished && promiseResolve) {\n        promiseResolve({ value: undefined, done: true })\n        promiseResolve = promiseReject = null\n      }\n    }\n\n    function onentry (header, stream, callback) {\n      entryCallback = callback\n      stream.on('error', noop) // no way around this due to tick sillyness\n\n      if (promiseResolve) {\n        promiseResolve({ value: stream, done: false })\n        promiseResolve = promiseReject = null\n      } else {\n        entryStream = stream\n      }\n    }\n\n    function onclose () {\n      consumeCallback(error)\n      if (!promiseResolve) return\n      if (error) promiseReject(error)\n      else promiseResolve({ value: undefined, done: true })\n      promiseResolve = promiseReject = null\n    }\n\n    function destroy (err) {\n      extract.destroy(err)\n      consumeCallback(err)\n      return new Promise((resolve, reject) => {\n        if (extract.destroyed) return resolve({ value: undefined, done: true })\n        extract.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nmodule.exports = function extract (opts) {\n  return new Extract(opts)\n}\n\nfunction noop () {}\n\nfunction overflow (size) {\n  size &= 511\n  return size && 512 - size\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9leHRyYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEscUNBQXFDLEVBQUUsbUJBQU8sQ0FBQyxzREFBUztBQUNoRSxhQUFhLG1CQUFPLENBQUMsMERBQVc7QUFDaEMsWUFBWSxtQkFBTyxDQUFDLDhDQUFLO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFXOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLDhCQUE4QjtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsOEJBQThCO0FBQzlFO0FBQ0E7QUFDQSx5QkFBeUIsOEJBQThCO0FBQ3ZELFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2F1Y3Rpb24tc2NyYXBwZXIvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9leHRyYWN0LmpzPzg0ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBXcml0YWJsZSwgUmVhZGFibGUsIGdldFN0cmVhbUVycm9yIH0gPSByZXF1aXJlKCdzdHJlYW14JylcbmNvbnN0IEZJRk8gPSByZXF1aXJlKCdmYXN0LWZpZm8nKVxuY29uc3QgYjRhID0gcmVxdWlyZSgnYjRhJylcbmNvbnN0IGhlYWRlcnMgPSByZXF1aXJlKCcuL2hlYWRlcnMnKVxuXG5jb25zdCBFTVBUWSA9IGI0YS5hbGxvYygwKVxuXG5jbGFzcyBCdWZmZXJMaXN0IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuYnVmZmVyZWQgPSAwXG4gICAgdGhpcy5zaGlmdGVkID0gMFxuICAgIHRoaXMucXVldWUgPSBuZXcgRklGTygpXG5cbiAgICB0aGlzLl9vZmZzZXQgPSAwXG4gIH1cblxuICBwdXNoIChidWZmZXIpIHtcbiAgICB0aGlzLmJ1ZmZlcmVkICs9IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgdGhpcy5xdWV1ZS5wdXNoKGJ1ZmZlcilcbiAgfVxuXG4gIHNoaWZ0Rmlyc3QgKHNpemUpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVmZmVyZWQgPT09IDAgPyBudWxsIDogdGhpcy5fbmV4dChzaXplKVxuICB9XG5cbiAgc2hpZnQgKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA+IHRoaXMuYnVmZmVyZWQpIHJldHVybiBudWxsXG4gICAgaWYgKHNpemUgPT09IDApIHJldHVybiBFTVBUWVxuXG4gICAgbGV0IGNodW5rID0gdGhpcy5fbmV4dChzaXplKVxuXG4gICAgaWYgKHNpemUgPT09IGNodW5rLmJ5dGVMZW5ndGgpIHJldHVybiBjaHVuayAvLyBsaWtlbHkgY2FzZVxuXG4gICAgY29uc3QgY2h1bmtzID0gW2NodW5rXVxuXG4gICAgd2hpbGUgKChzaXplIC09IGNodW5rLmJ5dGVMZW5ndGgpID4gMCkge1xuICAgICAgY2h1bmsgPSB0aGlzLl9uZXh0KHNpemUpXG4gICAgICBjaHVua3MucHVzaChjaHVuaylcbiAgICB9XG5cbiAgICByZXR1cm4gYjRhLmNvbmNhdChjaHVua3MpXG4gIH1cblxuICBfbmV4dCAoc2l6ZSkge1xuICAgIGNvbnN0IGJ1ZiA9IHRoaXMucXVldWUucGVlaygpXG4gICAgY29uc3QgcmVtID0gYnVmLmJ5dGVMZW5ndGggLSB0aGlzLl9vZmZzZXRcblxuICAgIGlmIChzaXplID49IHJlbSkge1xuICAgICAgY29uc3Qgc3ViID0gdGhpcy5fb2Zmc2V0ID8gYnVmLnN1YmFycmF5KHRoaXMuX29mZnNldCwgYnVmLmJ5dGVMZW5ndGgpIDogYnVmXG4gICAgICB0aGlzLnF1ZXVlLnNoaWZ0KClcbiAgICAgIHRoaXMuX29mZnNldCA9IDBcbiAgICAgIHRoaXMuYnVmZmVyZWQgLT0gcmVtXG4gICAgICB0aGlzLnNoaWZ0ZWQgKz0gcmVtXG4gICAgICByZXR1cm4gc3ViXG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXJlZCAtPSBzaXplXG4gICAgdGhpcy5zaGlmdGVkICs9IHNpemVcblxuICAgIHJldHVybiBidWYuc3ViYXJyYXkodGhpcy5fb2Zmc2V0LCAodGhpcy5fb2Zmc2V0ICs9IHNpemUpKVxuICB9XG59XG5cbmNsYXNzIFNvdXJjZSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKHNlbGYsIGhlYWRlciwgb2Zmc2V0KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5oZWFkZXIgPSBoZWFkZXJcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldFxuXG4gICAgdGhpcy5fcGFyZW50ID0gc2VsZlxuICB9XG5cbiAgX3JlYWQgKGNiKSB7XG4gICAgaWYgKHRoaXMuaGVhZGVyLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMucHVzaChudWxsKVxuICAgIH1cbiAgICBpZiAodGhpcy5fcGFyZW50Ll9zdHJlYW0gPT09IHRoaXMpIHtcbiAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlKClcbiAgICB9XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF9wcmVkZXN0cm95ICgpIHtcbiAgICB0aGlzLl9wYXJlbnQuZGVzdHJveShnZXRTdHJlYW1FcnJvcih0aGlzKSlcbiAgfVxuXG4gIF9kZXRhY2ggKCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnQuX3N0cmVhbSA9PT0gdGhpcykge1xuICAgICAgdGhpcy5fcGFyZW50Ll9zdHJlYW0gPSBudWxsXG4gICAgICB0aGlzLl9wYXJlbnQuX21pc3NpbmcgPSBvdmVyZmxvdyh0aGlzLmhlYWRlci5zaXplKVxuICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95IChjYikge1xuICAgIHRoaXMuX2RldGFjaCgpXG4gICAgY2IobnVsbClcbiAgfVxufVxuXG5jbGFzcyBFeHRyYWN0IGV4dGVuZHMgV3JpdGFibGUge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG5cbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gICAgdGhpcy5fYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKVxuICAgIHRoaXMuX29mZnNldCA9IDBcbiAgICB0aGlzLl9oZWFkZXIgPSBudWxsXG4gICAgdGhpcy5fc3RyZWFtID0gbnVsbFxuICAgIHRoaXMuX21pc3NpbmcgPSAwXG4gICAgdGhpcy5fbG9uZ0hlYWRlciA9IGZhbHNlXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBub29wXG4gICAgdGhpcy5fbG9ja2VkID0gZmFsc2VcbiAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlXG4gICAgdGhpcy5fcGF4ID0gbnVsbFxuICAgIHRoaXMuX3BheEdsb2JhbCA9IG51bGxcbiAgICB0aGlzLl9nbnVMb25nUGF0aCA9IG51bGxcbiAgICB0aGlzLl9nbnVMb25nTGlua1BhdGggPSBudWxsXG4gICAgdGhpcy5fZmlsZW5hbWVFbmNvZGluZyA9IG9wdHMuZmlsZW5hbWVFbmNvZGluZyB8fCAndXRmLTgnXG4gICAgdGhpcy5fYWxsb3dVbmtub3duRm9ybWF0ID0gISFvcHRzLmFsbG93VW5rbm93bkZvcm1hdFxuICAgIHRoaXMuX3VubG9ja0JvdW5kID0gdGhpcy5fdW5sb2NrLmJpbmQodGhpcylcbiAgfVxuXG4gIF91bmxvY2sgKGVycikge1xuICAgIHRoaXMuX2xvY2tlZCA9IGZhbHNlXG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyKVxuICAgICAgdGhpcy5fY29udGludWVXcml0ZShlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGUoKVxuICB9XG5cbiAgX2NvbnN1bWVIZWFkZXIgKCkge1xuICAgIGlmICh0aGlzLl9sb2NrZWQpIHJldHVybiBmYWxzZVxuXG4gICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fYnVmZmVyLnNoaWZ0ZWRcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9oZWFkZXIgPSBoZWFkZXJzLmRlY29kZSh0aGlzLl9idWZmZXIuc2hpZnQoNTEyKSwgdGhpcy5fZmlsZW5hbWVFbmNvZGluZywgdGhpcy5fYWxsb3dVbmtub3duRm9ybWF0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fY29udGludWVXcml0ZShlcnIpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2hlYWRlcikgcmV0dXJuIHRydWVcblxuICAgIHN3aXRjaCAodGhpcy5faGVhZGVyLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2dudS1sb25nLXBhdGgnOlxuICAgICAgY2FzZSAnZ251LWxvbmctbGluay1wYXRoJzpcbiAgICAgIGNhc2UgJ3BheC1nbG9iYWwtaGVhZGVyJzpcbiAgICAgIGNhc2UgJ3BheC1oZWFkZXInOlxuICAgICAgICB0aGlzLl9sb25nSGVhZGVyID0gdHJ1ZVxuICAgICAgICB0aGlzLl9taXNzaW5nID0gdGhpcy5faGVhZGVyLnNpemVcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB0aGlzLl9sb2NrZWQgPSB0cnVlXG4gICAgdGhpcy5fYXBwbHlMb25nSGVhZGVycygpXG5cbiAgICBpZiAodGhpcy5faGVhZGVyLnNpemUgPT09IDAgfHwgdGhpcy5faGVhZGVyLnR5cGUgPT09ICdkaXJlY3RvcnknKSB7XG4gICAgICB0aGlzLmVtaXQoJ2VudHJ5JywgdGhpcy5faGVhZGVyLCB0aGlzLl9jcmVhdGVTdHJlYW0oKSwgdGhpcy5fdW5sb2NrQm91bmQpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMuX3N0cmVhbSA9IHRoaXMuX2NyZWF0ZVN0cmVhbSgpXG4gICAgdGhpcy5fbWlzc2luZyA9IHRoaXMuX2hlYWRlci5zaXplXG5cbiAgICB0aGlzLmVtaXQoJ2VudHJ5JywgdGhpcy5faGVhZGVyLCB0aGlzLl9zdHJlYW0sIHRoaXMuX3VubG9ja0JvdW5kKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBfYXBwbHlMb25nSGVhZGVycyAoKSB7XG4gICAgaWYgKHRoaXMuX2dudUxvbmdQYXRoKSB7XG4gICAgICB0aGlzLl9oZWFkZXIubmFtZSA9IHRoaXMuX2dudUxvbmdQYXRoXG4gICAgICB0aGlzLl9nbnVMb25nUGF0aCA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZ251TG9uZ0xpbmtQYXRoKSB7XG4gICAgICB0aGlzLl9oZWFkZXIubGlua25hbWUgPSB0aGlzLl9nbnVMb25nTGlua1BhdGhcbiAgICAgIHRoaXMuX2dudUxvbmdMaW5rUGF0aCA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF4KSB7XG4gICAgICBpZiAodGhpcy5fcGF4LnBhdGgpIHRoaXMuX2hlYWRlci5uYW1lID0gdGhpcy5fcGF4LnBhdGhcbiAgICAgIGlmICh0aGlzLl9wYXgubGlua3BhdGgpIHRoaXMuX2hlYWRlci5saW5rbmFtZSA9IHRoaXMuX3BheC5saW5rcGF0aFxuICAgICAgaWYgKHRoaXMuX3BheC5zaXplKSB0aGlzLl9oZWFkZXIuc2l6ZSA9IHBhcnNlSW50KHRoaXMuX3BheC5zaXplLCAxMClcbiAgICAgIHRoaXMuX2hlYWRlci5wYXggPSB0aGlzLl9wYXhcbiAgICAgIHRoaXMuX3BheCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBfZGVjb2RlTG9uZ0hlYWRlciAoYnVmKSB7XG4gICAgc3dpdGNoICh0aGlzLl9oZWFkZXIudHlwZSkge1xuICAgICAgY2FzZSAnZ251LWxvbmctcGF0aCc6XG4gICAgICAgIHRoaXMuX2dudUxvbmdQYXRoID0gaGVhZGVycy5kZWNvZGVMb25nUGF0aChidWYsIHRoaXMuX2ZpbGVuYW1lRW5jb2RpbmcpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdnbnUtbG9uZy1saW5rLXBhdGgnOlxuICAgICAgICB0aGlzLl9nbnVMb25nTGlua1BhdGggPSBoZWFkZXJzLmRlY29kZUxvbmdQYXRoKGJ1ZiwgdGhpcy5fZmlsZW5hbWVFbmNvZGluZylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BheC1nbG9iYWwtaGVhZGVyJzpcbiAgICAgICAgdGhpcy5fcGF4R2xvYmFsID0gaGVhZGVycy5kZWNvZGVQYXgoYnVmKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncGF4LWhlYWRlcic6XG4gICAgICAgIHRoaXMuX3BheCA9IHRoaXMuX3BheEdsb2JhbCA9PT0gbnVsbFxuICAgICAgICAgID8gaGVhZGVycy5kZWNvZGVQYXgoYnVmKVxuICAgICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fcGF4R2xvYmFsLCBoZWFkZXJzLmRlY29kZVBheChidWYpKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIF9jb25zdW1lTG9uZ0hlYWRlciAoKSB7XG4gICAgdGhpcy5fbG9uZ0hlYWRlciA9IGZhbHNlXG4gICAgdGhpcy5fbWlzc2luZyA9IG92ZXJmbG93KHRoaXMuX2hlYWRlci5zaXplKVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyLnNoaWZ0KHRoaXMuX2hlYWRlci5zaXplKVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2RlY29kZUxvbmdIZWFkZXIoYnVmKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fY29udGludWVXcml0ZShlcnIpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgX2NvbnN1bWVTdHJlYW0gKCkge1xuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlci5zaGlmdEZpcnN0KHRoaXMuX21pc3NpbmcpXG4gICAgaWYgKGJ1ZiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlXG5cbiAgICB0aGlzLl9taXNzaW5nIC09IGJ1Zi5ieXRlTGVuZ3RoXG4gICAgY29uc3QgZHJhaW5lZCA9IHRoaXMuX3N0cmVhbS5wdXNoKGJ1ZilcblxuICAgIGlmICh0aGlzLl9taXNzaW5nID09PSAwKSB7XG4gICAgICB0aGlzLl9zdHJlYW0ucHVzaChudWxsKVxuICAgICAgaWYgKGRyYWluZWQpIHRoaXMuX3N0cmVhbS5fZGV0YWNoKClcbiAgICAgIHJldHVybiBkcmFpbmVkICYmIHRoaXMuX2xvY2tlZCA9PT0gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gZHJhaW5lZFxuICB9XG5cbiAgX2NyZWF0ZVN0cmVhbSAoKSB7XG4gICAgcmV0dXJuIG5ldyBTb3VyY2UodGhpcywgdGhpcy5faGVhZGVyLCB0aGlzLl9vZmZzZXQpXG4gIH1cblxuICBfdXBkYXRlICgpIHtcbiAgICB3aGlsZSAodGhpcy5fYnVmZmVyLmJ1ZmZlcmVkID4gMCAmJiAhdGhpcy5kZXN0cm95aW5nKSB7XG4gICAgICBpZiAodGhpcy5fbWlzc2luZyA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0cmVhbSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0aGlzLl9jb25zdW1lU3RyZWFtKCkgPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2xvbmdIZWFkZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbWlzc2luZyA+IHRoaXMuX2J1ZmZlci5idWZmZXJlZCkgYnJlYWtcbiAgICAgICAgICBpZiAodGhpcy5fY29uc3VtZUxvbmdIZWFkZXIoKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZ25vcmUgPSB0aGlzLl9idWZmZXIuc2hpZnRGaXJzdCh0aGlzLl9taXNzaW5nKVxuICAgICAgICBpZiAoaWdub3JlICE9PSBudWxsKSB0aGlzLl9taXNzaW5nIC09IGlnbm9yZS5ieXRlTGVuZ3RoXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9idWZmZXIuYnVmZmVyZWQgPCA1MTIpIGJyZWFrXG4gICAgICBpZiAodGhpcy5fc3RyZWFtICE9PSBudWxsIHx8IHRoaXMuX2NvbnN1bWVIZWFkZXIoKSA9PT0gZmFsc2UpIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2NvbnRpbnVlV3JpdGUobnVsbClcbiAgfVxuXG4gIF9jb250aW51ZVdyaXRlIChlcnIpIHtcbiAgICBjb25zdCBjYiA9IHRoaXMuX2NhbGxiYWNrXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBub29wXG4gICAgY2IoZXJyKVxuICB9XG5cbiAgX3dyaXRlIChkYXRhLCBjYikge1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2JcbiAgICB0aGlzLl9idWZmZXIucHVzaChkYXRhKVxuICAgIHRoaXMuX3VwZGF0ZSgpXG4gIH1cblxuICBfZmluYWwgKGNiKSB7XG4gICAgdGhpcy5fZmluaXNoZWQgPSB0aGlzLl9taXNzaW5nID09PSAwICYmIHRoaXMuX2J1ZmZlci5idWZmZXJlZCA9PT0gMFxuICAgIGNiKHRoaXMuX2ZpbmlzaGVkID8gbnVsbCA6IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZGF0YScpKVxuICB9XG5cbiAgX3ByZWRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX2NvbnRpbnVlV3JpdGUobnVsbClcbiAgfVxuXG4gIF9kZXN0cm95IChjYikge1xuICAgIGlmICh0aGlzLl9zdHJlYW0pIHRoaXMuX3N0cmVhbS5kZXN0cm95KGdldFN0cmVhbUVycm9yKHRoaXMpKVxuICAgIGNiKG51bGwpXG4gIH1cblxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdICgpIHtcbiAgICBsZXQgZXJyb3IgPSBudWxsXG5cbiAgICBsZXQgcHJvbWlzZVJlc29sdmUgPSBudWxsXG4gICAgbGV0IHByb21pc2VSZWplY3QgPSBudWxsXG5cbiAgICBsZXQgZW50cnlTdHJlYW0gPSBudWxsXG4gICAgbGV0IGVudHJ5Q2FsbGJhY2sgPSBudWxsXG5cbiAgICBjb25zdCBleHRyYWN0ID0gdGhpc1xuXG4gICAgdGhpcy5vbignZW50cnknLCBvbmVudHJ5KVxuICAgIHRoaXMub24oJ2Vycm9yJywgKGVycikgPT4geyBlcnJvciA9IGVyciB9KVxuICAgIHRoaXMub24oJ2Nsb3NlJywgb25jbG9zZSlcblxuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICBuZXh0ICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKG9ubmV4dClcbiAgICAgIH0sXG4gICAgICByZXR1cm4gKCkge1xuICAgICAgICByZXR1cm4gZGVzdHJveShudWxsKVxuICAgICAgfSxcbiAgICAgIHRocm93IChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGRlc3Ryb3koZXJyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnN1bWVDYWxsYmFjayAoZXJyKSB7XG4gICAgICBpZiAoIWVudHJ5Q2FsbGJhY2spIHJldHVyblxuICAgICAgY29uc3QgY2IgPSBlbnRyeUNhbGxiYWNrXG4gICAgICBlbnRyeUNhbGxiYWNrID0gbnVsbFxuICAgICAgY2IoZXJyKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ubmV4dCAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcilcbiAgICAgIH1cblxuICAgICAgaWYgKGVudHJ5U3RyZWFtKSB7XG4gICAgICAgIHJlc29sdmUoeyB2YWx1ZTogZW50cnlTdHJlYW0sIGRvbmU6IGZhbHNlIH0pXG4gICAgICAgIGVudHJ5U3RyZWFtID0gbnVsbFxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlXG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0XG5cbiAgICAgIGNvbnN1bWVDYWxsYmFjayhudWxsKVxuXG4gICAgICBpZiAoZXh0cmFjdC5fZmluaXNoZWQgJiYgcHJvbWlzZVJlc29sdmUpIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pXG4gICAgICAgIHByb21pc2VSZXNvbHZlID0gcHJvbWlzZVJlamVjdCA9IG51bGxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmVudHJ5IChoZWFkZXIsIHN0cmVhbSwgY2FsbGJhY2spIHtcbiAgICAgIGVudHJ5Q2FsbGJhY2sgPSBjYWxsYmFja1xuICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIG5vb3ApIC8vIG5vIHdheSBhcm91bmQgdGhpcyBkdWUgdG8gdGljayBzaWxseW5lc3NcblxuICAgICAgaWYgKHByb21pc2VSZXNvbHZlKSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHsgdmFsdWU6IHN0cmVhbSwgZG9uZTogZmFsc2UgfSlcbiAgICAgICAgcHJvbWlzZVJlc29sdmUgPSBwcm9taXNlUmVqZWN0ID0gbnVsbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50cnlTdHJlYW0gPSBzdHJlYW1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcbiAgICAgIGNvbnN1bWVDYWxsYmFjayhlcnJvcilcbiAgICAgIGlmICghcHJvbWlzZVJlc29sdmUpIHJldHVyblxuICAgICAgaWYgKGVycm9yKSBwcm9taXNlUmVqZWN0KGVycm9yKVxuICAgICAgZWxzZSBwcm9taXNlUmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSlcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcHJvbWlzZVJlamVjdCA9IG51bGxcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95IChlcnIpIHtcbiAgICAgIGV4dHJhY3QuZGVzdHJveShlcnIpXG4gICAgICBjb25zdW1lQ2FsbGJhY2soZXJyKVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKGV4dHJhY3QuZGVzdHJveWVkKSByZXR1cm4gcmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSlcbiAgICAgICAgZXh0cmFjdC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZXJyKSByZWplY3QoZXJyKVxuICAgICAgICAgIGVsc2UgcmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXh0cmFjdCAob3B0cykge1xuICByZXR1cm4gbmV3IEV4dHJhY3Qob3B0cylcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBvdmVyZmxvdyAoc2l6ZSkge1xuICBzaXplICY9IDUxMVxuICByZXR1cm4gc2l6ZSAmJiA1MTIgLSBzaXplXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar-stream/extract.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar-stream/headers.js":
/*!********************************************!*\
  !*** ./node_modules/tar-stream/headers.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const b4a = __webpack_require__(/*! b4a */ \"(rsc)/./node_modules/b4a/index.js\")\n\nconst ZEROS = '0000000000000000000'\nconst SEVENS = '7777777777777777777'\nconst ZERO_OFFSET = '0'.charCodeAt(0)\nconst USTAR_MAGIC = b4a.from([0x75, 0x73, 0x74, 0x61, 0x72, 0x00]) // ustar\\x00\nconst USTAR_VER = b4a.from([ZERO_OFFSET, ZERO_OFFSET])\nconst GNU_MAGIC = b4a.from([0x75, 0x73, 0x74, 0x61, 0x72, 0x20]) // ustar\\x20\nconst GNU_VER = b4a.from([0x20, 0x00])\nconst MASK = 0o7777\nconst MAGIC_OFFSET = 257\nconst VERSION_OFFSET = 263\n\nexports.decodeLongPath = function decodeLongPath (buf, encoding) {\n  return decodeStr(buf, 0, buf.length, encoding)\n}\n\nexports.encodePax = function encodePax (opts) { // TODO: encode more stuff in pax\n  let result = ''\n  if (opts.name) result += addLength(' path=' + opts.name + '\\n')\n  if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\\n')\n  const pax = opts.pax\n  if (pax) {\n    for (const key in pax) {\n      result += addLength(' ' + key + '=' + pax[key] + '\\n')\n    }\n  }\n  return b4a.from(result)\n}\n\nexports.decodePax = function decodePax (buf) {\n  const result = {}\n\n  while (buf.length) {\n    let i = 0\n    while (i < buf.length && buf[i] !== 32) i++\n    const len = parseInt(b4a.toString(buf.subarray(0, i)), 10)\n    if (!len) return result\n\n    const b = b4a.toString(buf.subarray(i + 1, len - 1))\n    const keyIndex = b.indexOf('=')\n    if (keyIndex === -1) return result\n    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)\n\n    buf = buf.subarray(len)\n  }\n\n  return result\n}\n\nexports.encode = function encode (opts) {\n  const buf = b4a.alloc(512)\n  let name = opts.name\n  let prefix = ''\n\n  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/'\n  if (b4a.byteLength(name) !== name.length) return null // utf-8\n\n  while (b4a.byteLength(name) > 100) {\n    const i = name.indexOf('/')\n    if (i === -1) return null\n    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i)\n    name = name.slice(i + 1)\n  }\n\n  if (b4a.byteLength(name) > 100 || b4a.byteLength(prefix) > 155) return null\n  if (opts.linkname && b4a.byteLength(opts.linkname) > 100) return null\n\n  b4a.write(buf, name)\n  b4a.write(buf, encodeOct(opts.mode & MASK, 6), 100)\n  b4a.write(buf, encodeOct(opts.uid, 6), 108)\n  b4a.write(buf, encodeOct(opts.gid, 6), 116)\n  encodeSize(opts.size, buf, 124)\n  b4a.write(buf, encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136)\n\n  buf[156] = ZERO_OFFSET + toTypeflag(opts.type)\n\n  if (opts.linkname) b4a.write(buf, opts.linkname, 157)\n\n  b4a.copy(USTAR_MAGIC, buf, MAGIC_OFFSET)\n  b4a.copy(USTAR_VER, buf, VERSION_OFFSET)\n  if (opts.uname) b4a.write(buf, opts.uname, 265)\n  if (opts.gname) b4a.write(buf, opts.gname, 297)\n  b4a.write(buf, encodeOct(opts.devmajor || 0, 6), 329)\n  b4a.write(buf, encodeOct(opts.devminor || 0, 6), 337)\n\n  if (prefix) b4a.write(buf, prefix, 345)\n\n  b4a.write(buf, encodeOct(cksum(buf), 6), 148)\n\n  return buf\n}\n\nexports.decode = function decode (buf, filenameEncoding, allowUnknownFormat) {\n  let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET\n\n  let name = decodeStr(buf, 0, 100, filenameEncoding)\n  const mode = decodeOct(buf, 100, 8)\n  const uid = decodeOct(buf, 108, 8)\n  const gid = decodeOct(buf, 116, 8)\n  const size = decodeOct(buf, 124, 12)\n  const mtime = decodeOct(buf, 136, 12)\n  const type = toType(typeflag)\n  const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding)\n  const uname = decodeStr(buf, 265, 32)\n  const gname = decodeStr(buf, 297, 32)\n  const devmajor = decodeOct(buf, 329, 8)\n  const devminor = decodeOct(buf, 337, 8)\n\n  const c = cksum(buf)\n\n  // checksum is still initial value if header was null.\n  if (c === 8 * 32) return null\n\n  // valid checksum\n  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')\n\n  if (isUSTAR(buf)) {\n    // ustar (posix) format.\n    // prepend prefix, if present.\n    if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name\n  } else if (isGNU(buf)) {\n    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and\n    // multi-volume tarballs.\n  } else {\n    if (!allowUnknownFormat) {\n      throw new Error('Invalid tar header: unknown format.')\n    }\n  }\n\n  // to support old tar versions that use trailing / to indicate dirs\n  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5\n\n  return {\n    name,\n    mode,\n    uid,\n    gid,\n    size,\n    mtime: new Date(1000 * mtime),\n    type,\n    linkname,\n    uname,\n    gname,\n    devmajor,\n    devminor,\n    pax: null\n  }\n}\n\nfunction isUSTAR (buf) {\n  return b4a.equals(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6))\n}\n\nfunction isGNU (buf) {\n  return b4a.equals(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) &&\n    b4a.equals(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2))\n}\n\nfunction clamp (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nfunction toType (flag) {\n  switch (flag) {\n    case 0:\n      return 'file'\n    case 1:\n      return 'link'\n    case 2:\n      return 'symlink'\n    case 3:\n      return 'character-device'\n    case 4:\n      return 'block-device'\n    case 5:\n      return 'directory'\n    case 6:\n      return 'fifo'\n    case 7:\n      return 'contiguous-file'\n    case 72:\n      return 'pax-header'\n    case 55:\n      return 'pax-global-header'\n    case 27:\n      return 'gnu-long-link-path'\n    case 28:\n    case 30:\n      return 'gnu-long-path'\n  }\n\n  return null\n}\n\nfunction toTypeflag (flag) {\n  switch (flag) {\n    case 'file':\n      return 0\n    case 'link':\n      return 1\n    case 'symlink':\n      return 2\n    case 'character-device':\n      return 3\n    case 'block-device':\n      return 4\n    case 'directory':\n      return 5\n    case 'fifo':\n      return 6\n    case 'contiguous-file':\n      return 7\n    case 'pax-header':\n      return 72\n  }\n\n  return 0\n}\n\nfunction indexOf (block, num, offset, end) {\n  for (; offset < end; offset++) {\n    if (block[offset] === num) return offset\n  }\n  return end\n}\n\nfunction cksum (block) {\n  let sum = 8 * 32\n  for (let i = 0; i < 148; i++) sum += block[i]\n  for (let j = 156; j < 512; j++) sum += block[j]\n  return sum\n}\n\nfunction encodeOct (val, n) {\n  val = val.toString(8)\n  if (val.length > n) return SEVENS.slice(0, n) + ' '\n  return ZEROS.slice(0, n - val.length) + val + ' '\n}\n\nfunction encodeSizeBin (num, buf, off) {\n  buf[off] = 0x80\n  for (let i = 11; i > 0; i--) {\n    buf[off + i] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nfunction encodeSize (num, buf, off) {\n  if (num.toString(8).length > 11) {\n    encodeSizeBin(num, buf, off)\n  } else {\n    b4a.write(buf, encodeOct(num, 11), off)\n  }\n}\n\n/* Copied from the node-tar repo and modified to meet\n * tar-stream coding standard.\n *\n * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349\n */\nfunction parse256 (buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  let positive\n  if (buf[0] === 0x80) positive = true\n  else if (buf[0] === 0xFF) positive = false\n  else return null\n\n  // build up a base-256 tuple from the least sig to the highest\n  const tuple = []\n  let i\n  for (i = buf.length - 1; i > 0; i--) {\n    const byte = buf[i]\n    if (positive) tuple.push(byte)\n    else tuple.push(0xFF - byte)\n  }\n\n  let sum = 0\n  const l = tuple.length\n  for (i = 0; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i)\n  }\n\n  return positive ? sum : -1 * sum\n}\n\nfunction decodeOct (val, offset, length) {\n  val = val.subarray(offset, offset + length)\n  offset = 0\n\n  // If prefixed with 0x80 then parse as a base-256 integer\n  if (val[offset] & 0x80) {\n    return parse256(val)\n  } else {\n    // Older versions of tar can prefix with spaces\n    while (offset < val.length && val[offset] === 32) offset++\n    const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)\n    while (offset < end && val[offset] === 0) offset++\n    if (end === offset) return 0\n    return parseInt(b4a.toString(val.subarray(offset, end)), 8)\n  }\n}\n\nfunction decodeStr (val, offset, length, encoding) {\n  return b4a.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding)\n}\n\nfunction addLength (str) {\n  const len = b4a.byteLength(str)\n  let digits = Math.floor(Math.log(len) / Math.log(10)) + 1\n  if (len + digits >= Math.pow(10, digits)) digits++\n\n  return (len + digits) + str\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9oZWFkZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVksbUJBQU8sQ0FBQyw4Q0FBSzs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUEsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGNBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXVjdGlvbi1zY3JhcHBlci8uL25vZGVfbW9kdWxlcy90YXItc3RyZWFtL2hlYWRlcnMuanM/NzQ2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBiNGEgPSByZXF1aXJlKCdiNGEnKVxuXG5jb25zdCBaRVJPUyA9ICcwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuY29uc3QgU0VWRU5TID0gJzc3Nzc3Nzc3Nzc3Nzc3Nzc3NzcnXG5jb25zdCBaRVJPX09GRlNFVCA9ICcwJy5jaGFyQ29kZUF0KDApXG5jb25zdCBVU1RBUl9NQUdJQyA9IGI0YS5mcm9tKFsweDc1LCAweDczLCAweDc0LCAweDYxLCAweDcyLCAweDAwXSkgLy8gdXN0YXJcXHgwMFxuY29uc3QgVVNUQVJfVkVSID0gYjRhLmZyb20oW1pFUk9fT0ZGU0VULCBaRVJPX09GRlNFVF0pXG5jb25zdCBHTlVfTUFHSUMgPSBiNGEuZnJvbShbMHg3NSwgMHg3MywgMHg3NCwgMHg2MSwgMHg3MiwgMHgyMF0pIC8vIHVzdGFyXFx4MjBcbmNvbnN0IEdOVV9WRVIgPSBiNGEuZnJvbShbMHgyMCwgMHgwMF0pXG5jb25zdCBNQVNLID0gMG83Nzc3XG5jb25zdCBNQUdJQ19PRkZTRVQgPSAyNTdcbmNvbnN0IFZFUlNJT05fT0ZGU0VUID0gMjYzXG5cbmV4cG9ydHMuZGVjb2RlTG9uZ1BhdGggPSBmdW5jdGlvbiBkZWNvZGVMb25nUGF0aCAoYnVmLCBlbmNvZGluZykge1xuICByZXR1cm4gZGVjb2RlU3RyKGJ1ZiwgMCwgYnVmLmxlbmd0aCwgZW5jb2RpbmcpXG59XG5cbmV4cG9ydHMuZW5jb2RlUGF4ID0gZnVuY3Rpb24gZW5jb2RlUGF4IChvcHRzKSB7IC8vIFRPRE86IGVuY29kZSBtb3JlIHN0dWZmIGluIHBheFxuICBsZXQgcmVzdWx0ID0gJydcbiAgaWYgKG9wdHMubmFtZSkgcmVzdWx0ICs9IGFkZExlbmd0aCgnIHBhdGg9JyArIG9wdHMubmFtZSArICdcXG4nKVxuICBpZiAob3B0cy5saW5rbmFtZSkgcmVzdWx0ICs9IGFkZExlbmd0aCgnIGxpbmtwYXRoPScgKyBvcHRzLmxpbmtuYW1lICsgJ1xcbicpXG4gIGNvbnN0IHBheCA9IG9wdHMucGF4XG4gIGlmIChwYXgpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXgpIHtcbiAgICAgIHJlc3VsdCArPSBhZGRMZW5ndGgoJyAnICsga2V5ICsgJz0nICsgcGF4W2tleV0gKyAnXFxuJylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGI0YS5mcm9tKHJlc3VsdClcbn1cblxuZXhwb3J0cy5kZWNvZGVQYXggPSBmdW5jdGlvbiBkZWNvZGVQYXggKGJ1Zikge1xuICBjb25zdCByZXN1bHQgPSB7fVxuXG4gIHdoaWxlIChidWYubGVuZ3RoKSB7XG4gICAgbGV0IGkgPSAwXG4gICAgd2hpbGUgKGkgPCBidWYubGVuZ3RoICYmIGJ1ZltpXSAhPT0gMzIpIGkrK1xuICAgIGNvbnN0IGxlbiA9IHBhcnNlSW50KGI0YS50b1N0cmluZyhidWYuc3ViYXJyYXkoMCwgaSkpLCAxMClcbiAgICBpZiAoIWxlbikgcmV0dXJuIHJlc3VsdFxuXG4gICAgY29uc3QgYiA9IGI0YS50b1N0cmluZyhidWYuc3ViYXJyYXkoaSArIDEsIGxlbiAtIDEpKVxuICAgIGNvbnN0IGtleUluZGV4ID0gYi5pbmRleE9mKCc9JylcbiAgICBpZiAoa2V5SW5kZXggPT09IC0xKSByZXR1cm4gcmVzdWx0XG4gICAgcmVzdWx0W2Iuc2xpY2UoMCwga2V5SW5kZXgpXSA9IGIuc2xpY2Uoa2V5SW5kZXggKyAxKVxuXG4gICAgYnVmID0gYnVmLnN1YmFycmF5KGxlbilcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUgKG9wdHMpIHtcbiAgY29uc3QgYnVmID0gYjRhLmFsbG9jKDUxMilcbiAgbGV0IG5hbWUgPSBvcHRzLm5hbWVcbiAgbGV0IHByZWZpeCA9ICcnXG5cbiAgaWYgKG9wdHMudHlwZWZsYWcgPT09IDUgJiYgbmFtZVtuYW1lLmxlbmd0aCAtIDFdICE9PSAnLycpIG5hbWUgKz0gJy8nXG4gIGlmIChiNGEuYnl0ZUxlbmd0aChuYW1lKSAhPT0gbmFtZS5sZW5ndGgpIHJldHVybiBudWxsIC8vIHV0Zi04XG5cbiAgd2hpbGUgKGI0YS5ieXRlTGVuZ3RoKG5hbWUpID4gMTAwKSB7XG4gICAgY29uc3QgaSA9IG5hbWUuaW5kZXhPZignLycpXG4gICAgaWYgKGkgPT09IC0xKSByZXR1cm4gbnVsbFxuICAgIHByZWZpeCArPSBwcmVmaXggPyAnLycgKyBuYW1lLnNsaWNlKDAsIGkpIDogbmFtZS5zbGljZSgwLCBpKVxuICAgIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKVxuICB9XG5cbiAgaWYgKGI0YS5ieXRlTGVuZ3RoKG5hbWUpID4gMTAwIHx8IGI0YS5ieXRlTGVuZ3RoKHByZWZpeCkgPiAxNTUpIHJldHVybiBudWxsXG4gIGlmIChvcHRzLmxpbmtuYW1lICYmIGI0YS5ieXRlTGVuZ3RoKG9wdHMubGlua25hbWUpID4gMTAwKSByZXR1cm4gbnVsbFxuXG4gIGI0YS53cml0ZShidWYsIG5hbWUpXG4gIGI0YS53cml0ZShidWYsIGVuY29kZU9jdChvcHRzLm1vZGUgJiBNQVNLLCA2KSwgMTAwKVxuICBiNGEud3JpdGUoYnVmLCBlbmNvZGVPY3Qob3B0cy51aWQsIDYpLCAxMDgpXG4gIGI0YS53cml0ZShidWYsIGVuY29kZU9jdChvcHRzLmdpZCwgNiksIDExNilcbiAgZW5jb2RlU2l6ZShvcHRzLnNpemUsIGJ1ZiwgMTI0KVxuICBiNGEud3JpdGUoYnVmLCBlbmNvZGVPY3QoKG9wdHMubXRpbWUuZ2V0VGltZSgpIC8gMTAwMCkgfCAwLCAxMSksIDEzNilcblxuICBidWZbMTU2XSA9IFpFUk9fT0ZGU0VUICsgdG9UeXBlZmxhZyhvcHRzLnR5cGUpXG5cbiAgaWYgKG9wdHMubGlua25hbWUpIGI0YS53cml0ZShidWYsIG9wdHMubGlua25hbWUsIDE1NylcblxuICBiNGEuY29weShVU1RBUl9NQUdJQywgYnVmLCBNQUdJQ19PRkZTRVQpXG4gIGI0YS5jb3B5KFVTVEFSX1ZFUiwgYnVmLCBWRVJTSU9OX09GRlNFVClcbiAgaWYgKG9wdHMudW5hbWUpIGI0YS53cml0ZShidWYsIG9wdHMudW5hbWUsIDI2NSlcbiAgaWYgKG9wdHMuZ25hbWUpIGI0YS53cml0ZShidWYsIG9wdHMuZ25hbWUsIDI5NylcbiAgYjRhLndyaXRlKGJ1ZiwgZW5jb2RlT2N0KG9wdHMuZGV2bWFqb3IgfHwgMCwgNiksIDMyOSlcbiAgYjRhLndyaXRlKGJ1ZiwgZW5jb2RlT2N0KG9wdHMuZGV2bWlub3IgfHwgMCwgNiksIDMzNylcblxuICBpZiAocHJlZml4KSBiNGEud3JpdGUoYnVmLCBwcmVmaXgsIDM0NSlcblxuICBiNGEud3JpdGUoYnVmLCBlbmNvZGVPY3QoY2tzdW0oYnVmKSwgNiksIDE0OClcblxuICByZXR1cm4gYnVmXG59XG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlIChidWYsIGZpbGVuYW1lRW5jb2RpbmcsIGFsbG93VW5rbm93bkZvcm1hdCkge1xuICBsZXQgdHlwZWZsYWcgPSBidWZbMTU2XSA9PT0gMCA/IDAgOiBidWZbMTU2XSAtIFpFUk9fT0ZGU0VUXG5cbiAgbGV0IG5hbWUgPSBkZWNvZGVTdHIoYnVmLCAwLCAxMDAsIGZpbGVuYW1lRW5jb2RpbmcpXG4gIGNvbnN0IG1vZGUgPSBkZWNvZGVPY3QoYnVmLCAxMDAsIDgpXG4gIGNvbnN0IHVpZCA9IGRlY29kZU9jdChidWYsIDEwOCwgOClcbiAgY29uc3QgZ2lkID0gZGVjb2RlT2N0KGJ1ZiwgMTE2LCA4KVxuICBjb25zdCBzaXplID0gZGVjb2RlT2N0KGJ1ZiwgMTI0LCAxMilcbiAgY29uc3QgbXRpbWUgPSBkZWNvZGVPY3QoYnVmLCAxMzYsIDEyKVxuICBjb25zdCB0eXBlID0gdG9UeXBlKHR5cGVmbGFnKVxuICBjb25zdCBsaW5rbmFtZSA9IGJ1ZlsxNTddID09PSAwID8gbnVsbCA6IGRlY29kZVN0cihidWYsIDE1NywgMTAwLCBmaWxlbmFtZUVuY29kaW5nKVxuICBjb25zdCB1bmFtZSA9IGRlY29kZVN0cihidWYsIDI2NSwgMzIpXG4gIGNvbnN0IGduYW1lID0gZGVjb2RlU3RyKGJ1ZiwgMjk3LCAzMilcbiAgY29uc3QgZGV2bWFqb3IgPSBkZWNvZGVPY3QoYnVmLCAzMjksIDgpXG4gIGNvbnN0IGRldm1pbm9yID0gZGVjb2RlT2N0KGJ1ZiwgMzM3LCA4KVxuXG4gIGNvbnN0IGMgPSBja3N1bShidWYpXG5cbiAgLy8gY2hlY2tzdW0gaXMgc3RpbGwgaW5pdGlhbCB2YWx1ZSBpZiBoZWFkZXIgd2FzIG51bGwuXG4gIGlmIChjID09PSA4ICogMzIpIHJldHVybiBudWxsXG5cbiAgLy8gdmFsaWQgY2hlY2tzdW1cbiAgaWYgKGMgIT09IGRlY29kZU9jdChidWYsIDE0OCwgOCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YXIgaGVhZGVyLiBNYXliZSB0aGUgdGFyIGlzIGNvcnJ1cHRlZCBvciBpdCBuZWVkcyB0byBiZSBndW56aXBwZWQ/JylcblxuICBpZiAoaXNVU1RBUihidWYpKSB7XG4gICAgLy8gdXN0YXIgKHBvc2l4KSBmb3JtYXQuXG4gICAgLy8gcHJlcGVuZCBwcmVmaXgsIGlmIHByZXNlbnQuXG4gICAgaWYgKGJ1ZlszNDVdKSBuYW1lID0gZGVjb2RlU3RyKGJ1ZiwgMzQ1LCAxNTUsIGZpbGVuYW1lRW5jb2RpbmcpICsgJy8nICsgbmFtZVxuICB9IGVsc2UgaWYgKGlzR05VKGJ1ZikpIHtcbiAgICAvLyAnZ251Jy8nb2xkZ251JyBmb3JtYXQuIFNpbWlsYXIgdG8gdXN0YXIsIGJ1dCBoYXMgc3VwcG9ydCBmb3IgaW5jcmVtZW50YWwgYW5kXG4gICAgLy8gbXVsdGktdm9sdW1lIHRhcmJhbGxzLlxuICB9IGVsc2Uge1xuICAgIGlmICghYWxsb3dVbmtub3duRm9ybWF0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFyIGhlYWRlcjogdW5rbm93biBmb3JtYXQuJylcbiAgICB9XG4gIH1cblxuICAvLyB0byBzdXBwb3J0IG9sZCB0YXIgdmVyc2lvbnMgdGhhdCB1c2UgdHJhaWxpbmcgLyB0byBpbmRpY2F0ZSBkaXJzXG4gIGlmICh0eXBlZmxhZyA9PT0gMCAmJiBuYW1lICYmIG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJy8nKSB0eXBlZmxhZyA9IDVcblxuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgbW9kZSxcbiAgICB1aWQsXG4gICAgZ2lkLFxuICAgIHNpemUsXG4gICAgbXRpbWU6IG5ldyBEYXRlKDEwMDAgKiBtdGltZSksXG4gICAgdHlwZSxcbiAgICBsaW5rbmFtZSxcbiAgICB1bmFtZSxcbiAgICBnbmFtZSxcbiAgICBkZXZtYWpvcixcbiAgICBkZXZtaW5vcixcbiAgICBwYXg6IG51bGxcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VTVEFSIChidWYpIHtcbiAgcmV0dXJuIGI0YS5lcXVhbHMoVVNUQVJfTUFHSUMsIGJ1Zi5zdWJhcnJheShNQUdJQ19PRkZTRVQsIE1BR0lDX09GRlNFVCArIDYpKVxufVxuXG5mdW5jdGlvbiBpc0dOVSAoYnVmKSB7XG4gIHJldHVybiBiNGEuZXF1YWxzKEdOVV9NQUdJQywgYnVmLnN1YmFycmF5KE1BR0lDX09GRlNFVCwgTUFHSUNfT0ZGU0VUICsgNikpICYmXG4gICAgYjRhLmVxdWFscyhHTlVfVkVSLCBidWYuc3ViYXJyYXkoVkVSU0lPTl9PRkZTRVQsIFZFUlNJT05fT0ZGU0VUICsgMikpXG59XG5cbmZ1bmN0aW9uIGNsYW1wIChpbmRleCwgbGVuLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgaW5kZXggPSB+fmluZGV4IC8vIENvZXJjZSB0byBpbnRlZ2VyLlxuICBpZiAoaW5kZXggPj0gbGVuKSByZXR1cm4gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgaW5kZXggKz0gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gdG9UeXBlIChmbGFnKSB7XG4gIHN3aXRjaCAoZmxhZykge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiAnZmlsZSdcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gJ2xpbmsnXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuICdzeW1saW5rJ1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiAnY2hhcmFjdGVyLWRldmljZSdcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gJ2Jsb2NrLWRldmljZSdcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gJ2RpcmVjdG9yeSdcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gJ2ZpZm8nXG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuICdjb250aWd1b3VzLWZpbGUnXG4gICAgY2FzZSA3MjpcbiAgICAgIHJldHVybiAncGF4LWhlYWRlcidcbiAgICBjYXNlIDU1OlxuICAgICAgcmV0dXJuICdwYXgtZ2xvYmFsLWhlYWRlcidcbiAgICBjYXNlIDI3OlxuICAgICAgcmV0dXJuICdnbnUtbG9uZy1saW5rLXBhdGgnXG4gICAgY2FzZSAyODpcbiAgICBjYXNlIDMwOlxuICAgICAgcmV0dXJuICdnbnUtbG9uZy1wYXRoJ1xuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gdG9UeXBlZmxhZyAoZmxhZykge1xuICBzd2l0Y2ggKGZsYWcpIHtcbiAgICBjYXNlICdmaWxlJzpcbiAgICAgIHJldHVybiAwXG4gICAgY2FzZSAnbGluayc6XG4gICAgICByZXR1cm4gMVxuICAgIGNhc2UgJ3N5bWxpbmsnOlxuICAgICAgcmV0dXJuIDJcbiAgICBjYXNlICdjaGFyYWN0ZXItZGV2aWNlJzpcbiAgICAgIHJldHVybiAzXG4gICAgY2FzZSAnYmxvY2stZGV2aWNlJzpcbiAgICAgIHJldHVybiA0XG4gICAgY2FzZSAnZGlyZWN0b3J5JzpcbiAgICAgIHJldHVybiA1XG4gICAgY2FzZSAnZmlmbyc6XG4gICAgICByZXR1cm4gNlxuICAgIGNhc2UgJ2NvbnRpZ3VvdXMtZmlsZSc6XG4gICAgICByZXR1cm4gN1xuICAgIGNhc2UgJ3BheC1oZWFkZXInOlxuICAgICAgcmV0dXJuIDcyXG4gIH1cblxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBpbmRleE9mIChibG9jaywgbnVtLCBvZmZzZXQsIGVuZCkge1xuICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQrKykge1xuICAgIGlmIChibG9ja1tvZmZzZXRdID09PSBudW0pIHJldHVybiBvZmZzZXRcbiAgfVxuICByZXR1cm4gZW5kXG59XG5cbmZ1bmN0aW9uIGNrc3VtIChibG9jaykge1xuICBsZXQgc3VtID0gOCAqIDMyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTQ4OyBpKyspIHN1bSArPSBibG9ja1tpXVxuICBmb3IgKGxldCBqID0gMTU2OyBqIDwgNTEyOyBqKyspIHN1bSArPSBibG9ja1tqXVxuICByZXR1cm4gc3VtXG59XG5cbmZ1bmN0aW9uIGVuY29kZU9jdCAodmFsLCBuKSB7XG4gIHZhbCA9IHZhbC50b1N0cmluZyg4KVxuICBpZiAodmFsLmxlbmd0aCA+IG4pIHJldHVybiBTRVZFTlMuc2xpY2UoMCwgbikgKyAnICdcbiAgcmV0dXJuIFpFUk9TLnNsaWNlKDAsIG4gLSB2YWwubGVuZ3RoKSArIHZhbCArICcgJ1xufVxuXG5mdW5jdGlvbiBlbmNvZGVTaXplQmluIChudW0sIGJ1Ziwgb2ZmKSB7XG4gIGJ1ZltvZmZdID0gMHg4MFxuICBmb3IgKGxldCBpID0gMTE7IGkgPiAwOyBpLS0pIHtcbiAgICBidWZbb2ZmICsgaV0gPSBudW0gJiAweGZmXG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyAweDEwMClcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmNvZGVTaXplIChudW0sIGJ1Ziwgb2ZmKSB7XG4gIGlmIChudW0udG9TdHJpbmcoOCkubGVuZ3RoID4gMTEpIHtcbiAgICBlbmNvZGVTaXplQmluKG51bSwgYnVmLCBvZmYpXG4gIH0gZWxzZSB7XG4gICAgYjRhLndyaXRlKGJ1ZiwgZW5jb2RlT2N0KG51bSwgMTEpLCBvZmYpXG4gIH1cbn1cblxuLyogQ29waWVkIGZyb20gdGhlIG5vZGUtdGFyIHJlcG8gYW5kIG1vZGlmaWVkIHRvIG1lZXRcbiAqIHRhci1zdHJlYW0gY29kaW5nIHN0YW5kYXJkLlxuICpcbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL25wbS9ub2RlLXRhci9ibG9iLzUxYjY2MjdhMWYzNTdkMmViNDMzZTczNzhlNWYwNWU4M2I3YWE2Y2QvbGliL2hlYWRlci5qcyNMMzQ5XG4gKi9cbmZ1bmN0aW9uIHBhcnNlMjU2IChidWYpIHtcbiAgLy8gZmlyc3QgYnl0ZSBNVVNUIGJlIGVpdGhlciA4MCBvciBGRlxuICAvLyA4MCBmb3IgcG9zaXRpdmUsIEZGIGZvciAyJ3MgY29tcFxuICBsZXQgcG9zaXRpdmVcbiAgaWYgKGJ1ZlswXSA9PT0gMHg4MCkgcG9zaXRpdmUgPSB0cnVlXG4gIGVsc2UgaWYgKGJ1ZlswXSA9PT0gMHhGRikgcG9zaXRpdmUgPSBmYWxzZVxuICBlbHNlIHJldHVybiBudWxsXG5cbiAgLy8gYnVpbGQgdXAgYSBiYXNlLTI1NiB0dXBsZSBmcm9tIHRoZSBsZWFzdCBzaWcgdG8gdGhlIGhpZ2hlc3RcbiAgY29uc3QgdHVwbGUgPSBbXVxuICBsZXQgaVxuICBmb3IgKGkgPSBidWYubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgIGNvbnN0IGJ5dGUgPSBidWZbaV1cbiAgICBpZiAocG9zaXRpdmUpIHR1cGxlLnB1c2goYnl0ZSlcbiAgICBlbHNlIHR1cGxlLnB1c2goMHhGRiAtIGJ5dGUpXG4gIH1cblxuICBsZXQgc3VtID0gMFxuICBjb25zdCBsID0gdHVwbGUubGVuZ3RoXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBzdW0gKz0gdHVwbGVbaV0gKiBNYXRoLnBvdygyNTYsIGkpXG4gIH1cblxuICByZXR1cm4gcG9zaXRpdmUgPyBzdW0gOiAtMSAqIHN1bVxufVxuXG5mdW5jdGlvbiBkZWNvZGVPY3QgKHZhbCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFsID0gdmFsLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKVxuICBvZmZzZXQgPSAwXG5cbiAgLy8gSWYgcHJlZml4ZWQgd2l0aCAweDgwIHRoZW4gcGFyc2UgYXMgYSBiYXNlLTI1NiBpbnRlZ2VyXG4gIGlmICh2YWxbb2Zmc2V0XSAmIDB4ODApIHtcbiAgICByZXR1cm4gcGFyc2UyNTYodmFsKVxuICB9IGVsc2Uge1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIHRhciBjYW4gcHJlZml4IHdpdGggc3BhY2VzXG4gICAgd2hpbGUgKG9mZnNldCA8IHZhbC5sZW5ndGggJiYgdmFsW29mZnNldF0gPT09IDMyKSBvZmZzZXQrK1xuICAgIGNvbnN0IGVuZCA9IGNsYW1wKGluZGV4T2YodmFsLCAzMiwgb2Zmc2V0LCB2YWwubGVuZ3RoKSwgdmFsLmxlbmd0aCwgdmFsLmxlbmd0aClcbiAgICB3aGlsZSAob2Zmc2V0IDwgZW5kICYmIHZhbFtvZmZzZXRdID09PSAwKSBvZmZzZXQrK1xuICAgIGlmIChlbmQgPT09IG9mZnNldCkgcmV0dXJuIDBcbiAgICByZXR1cm4gcGFyc2VJbnQoYjRhLnRvU3RyaW5nKHZhbC5zdWJhcnJheShvZmZzZXQsIGVuZCkpLCA4KVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlY29kZVN0ciAodmFsLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGI0YS50b1N0cmluZyh2YWwuc3ViYXJyYXkob2Zmc2V0LCBpbmRleE9mKHZhbCwgMCwgb2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpKSwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFkZExlbmd0aCAoc3RyKSB7XG4gIGNvbnN0IGxlbiA9IGI0YS5ieXRlTGVuZ3RoKHN0cilcbiAgbGV0IGRpZ2l0cyA9IE1hdGguZmxvb3IoTWF0aC5sb2cobGVuKSAvIE1hdGgubG9nKDEwKSkgKyAxXG4gIGlmIChsZW4gKyBkaWdpdHMgPj0gTWF0aC5wb3coMTAsIGRpZ2l0cykpIGRpZ2l0cysrXG5cbiAgcmV0dXJuIChsZW4gKyBkaWdpdHMpICsgc3RyXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar-stream/headers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar-stream/index.js":
/*!******************************************!*\
  !*** ./node_modules/tar-stream/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.extract = __webpack_require__(/*! ./extract */ \"(rsc)/./node_modules/tar-stream/extract.js\")\nexports.pack = __webpack_require__(/*! ./pack */ \"(rsc)/./node_modules/tar-stream/pack.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvR0FBc0M7QUFDdEMsMkZBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXVjdGlvbi1zY3JhcHBlci8uL25vZGVfbW9kdWxlcy90YXItc3RyZWFtL2luZGV4LmpzPzcyNGMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5leHRyYWN0ID0gcmVxdWlyZSgnLi9leHRyYWN0JylcbmV4cG9ydHMucGFjayA9IHJlcXVpcmUoJy4vcGFjaycpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar-stream/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/tar-stream/pack.js":
/*!*****************************************!*\
  !*** ./node_modules/tar-stream/pack.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Readable, Writable, getStreamError } = __webpack_require__(/*! streamx */ \"(rsc)/./node_modules/streamx/index.js\")\nconst b4a = __webpack_require__(/*! b4a */ \"(rsc)/./node_modules/b4a/index.js\")\n\nconst constants = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/tar-stream/constants.js\")\nconst headers = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/tar-stream/headers.js\")\n\nconst DMODE = 0o755\nconst FMODE = 0o644\n\nconst END_OF_TAR = b4a.alloc(1024)\n\nclass Sink extends Writable {\n  constructor (pack, header, callback) {\n    super({ mapWritable, eagerOpen: true })\n\n    this.written = 0\n    this.header = header\n\n    this._callback = callback\n    this._linkname = null\n    this._isLinkname = header.type === 'symlink' && !header.linkname\n    this._isVoid = header.type !== 'file' && header.type !== 'contiguous-file'\n    this._finished = false\n    this._pack = pack\n    this._openCallback = null\n\n    if (this._pack._stream === null) this._pack._stream = this\n    else this._pack._pending.push(this)\n  }\n\n  _open (cb) {\n    this._openCallback = cb\n    if (this._pack._stream === this) this._continueOpen()\n  }\n\n  _continuePack (err) {\n    if (this._callback === null) return\n\n    const callback = this._callback\n    this._callback = null\n\n    callback(err)\n  }\n\n  _continueOpen () {\n    if (this._pack._stream === null) this._pack._stream = this\n\n    const cb = this._openCallback\n    this._openCallback = null\n    if (cb === null) return\n\n    if (this._pack.destroying) return cb(new Error('pack stream destroyed'))\n    if (this._pack._finalized) return cb(new Error('pack stream is already finalized'))\n\n    this._pack._stream = this\n\n    if (!this._isLinkname) {\n      this._pack._encode(this.header)\n    }\n\n    if (this._isVoid) {\n      this._finish()\n      this._continuePack(null)\n    }\n\n    cb(null)\n  }\n\n  _write (data, cb) {\n    if (this._isLinkname) {\n      this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data\n      return cb(null)\n    }\n\n    if (this._isVoid) {\n      if (data.byteLength > 0) {\n        return cb(new Error('No body allowed for this entry'))\n      }\n      return cb()\n    }\n\n    this.written += data.byteLength\n    if (this._pack.push(data)) return cb()\n    this._pack._drain = cb\n  }\n\n  _finish () {\n    if (this._finished) return\n    this._finished = true\n\n    if (this._isLinkname) {\n      this.header.linkname = this._linkname ? b4a.toString(this._linkname, 'utf-8') : ''\n      this._pack._encode(this.header)\n    }\n\n    overflow(this._pack, this.header.size)\n\n    this._pack._done(this)\n  }\n\n  _final (cb) {\n    if (this.written !== this.header.size) { // corrupting tar\n      return cb(new Error('Size mismatch'))\n    }\n\n    this._finish()\n    cb(null)\n  }\n\n  _getError () {\n    return getStreamError(this) || new Error('tar entry destroyed')\n  }\n\n  _predestroy () {\n    this._pack.destroy(this._getError())\n  }\n\n  _destroy (cb) {\n    this._pack._done(this)\n\n    this._continuePack(this._finished ? null : this._getError())\n\n    cb()\n  }\n}\n\nclass Pack extends Readable {\n  constructor (opts) {\n    super(opts)\n    this._drain = noop\n    this._finalized = false\n    this._finalizing = false\n    this._pending = []\n    this._stream = null\n  }\n\n  entry (header, buffer, callback) {\n    if (this._finalized || this.destroying) throw new Error('already finalized or destroyed')\n\n    if (typeof buffer === 'function') {\n      callback = buffer\n      buffer = null\n    }\n\n    if (!callback) callback = noop\n\n    if (!header.size || header.type === 'symlink') header.size = 0\n    if (!header.type) header.type = modeToType(header.mode)\n    if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE\n    if (!header.uid) header.uid = 0\n    if (!header.gid) header.gid = 0\n    if (!header.mtime) header.mtime = new Date()\n\n    if (typeof buffer === 'string') buffer = b4a.from(buffer)\n\n    const sink = new Sink(this, header, callback)\n\n    if (b4a.isBuffer(buffer)) {\n      header.size = buffer.byteLength\n      sink.write(buffer)\n      sink.end()\n      return sink\n    }\n\n    if (sink._isVoid) {\n      return sink\n    }\n\n    return sink\n  }\n\n  finalize () {\n    if (this._stream || this._pending.length > 0) {\n      this._finalizing = true\n      return\n    }\n\n    if (this._finalized) return\n    this._finalized = true\n\n    this.push(END_OF_TAR)\n    this.push(null)\n  }\n\n  _done (stream) {\n    if (stream !== this._stream) return\n\n    this._stream = null\n\n    if (this._finalizing) this.finalize()\n    if (this._pending.length) this._pending.shift()._continueOpen()\n  }\n\n  _encode (header) {\n    if (!header.pax) {\n      const buf = headers.encode(header)\n      if (buf) {\n        this.push(buf)\n        return\n      }\n    }\n    this._encodePax(header)\n  }\n\n  _encodePax (header) {\n    const paxHeader = headers.encodePax({\n      name: header.name,\n      linkname: header.linkname,\n      pax: header.pax\n    })\n\n    const newHeader = {\n      name: 'PaxHeader',\n      mode: header.mode,\n      uid: header.uid,\n      gid: header.gid,\n      size: paxHeader.byteLength,\n      mtime: header.mtime,\n      type: 'pax-header',\n      linkname: header.linkname && 'PaxHeader',\n      uname: header.uname,\n      gname: header.gname,\n      devmajor: header.devmajor,\n      devminor: header.devminor\n    }\n\n    this.push(headers.encode(newHeader))\n    this.push(paxHeader)\n    overflow(this, paxHeader.byteLength)\n\n    newHeader.size = header.size\n    newHeader.type = header.type\n    this.push(headers.encode(newHeader))\n  }\n\n  _doDrain () {\n    const drain = this._drain\n    this._drain = noop\n    drain()\n  }\n\n  _predestroy () {\n    const err = getStreamError(this)\n\n    if (this._stream) this._stream.destroy(err)\n\n    while (this._pending.length) {\n      const stream = this._pending.shift()\n      stream.destroy(err)\n      stream._continueOpen()\n    }\n\n    this._doDrain()\n  }\n\n  _read (cb) {\n    this._doDrain()\n    cb()\n  }\n}\n\nmodule.exports = function pack (opts) {\n  return new Pack(opts)\n}\n\nfunction modeToType (mode) {\n  switch (mode & constants.S_IFMT) {\n    case constants.S_IFBLK: return 'block-device'\n    case constants.S_IFCHR: return 'character-device'\n    case constants.S_IFDIR: return 'directory'\n    case constants.S_IFIFO: return 'fifo'\n    case constants.S_IFLNK: return 'symlink'\n  }\n\n  return 'file'\n}\n\nfunction noop () {}\n\nfunction overflow (self, size) {\n  size &= 511\n  if (size) self.push(END_OF_TAR.subarray(0, 512 - size))\n}\n\nfunction mapWritable (buf) {\n  return b4a.isBuffer(buf) ? buf : b4a.from(buf)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9wYWNrLmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEscUNBQXFDLEVBQUUsbUJBQU8sQ0FBQyxzREFBUztBQUNoRSxZQUFZLG1CQUFPLENBQUMsOENBQUs7O0FBRXpCLGtCQUFrQixtQkFBTyxDQUFDLGlFQUFhO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFXOztBQUVuQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4Qjs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdWN0aW9uLXNjcmFwcGVyLy4vbm9kZV9tb2R1bGVzL3Rhci1zdHJlYW0vcGFjay5qcz81ZmNjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgUmVhZGFibGUsIFdyaXRhYmxlLCBnZXRTdHJlYW1FcnJvciB9ID0gcmVxdWlyZSgnc3RyZWFteCcpXG5jb25zdCBiNGEgPSByZXF1aXJlKCdiNGEnKVxuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBoZWFkZXJzID0gcmVxdWlyZSgnLi9oZWFkZXJzJylcblxuY29uc3QgRE1PREUgPSAwbzc1NVxuY29uc3QgRk1PREUgPSAwbzY0NFxuXG5jb25zdCBFTkRfT0ZfVEFSID0gYjRhLmFsbG9jKDEwMjQpXG5cbmNsYXNzIFNpbmsgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIGNvbnN0cnVjdG9yIChwYWNrLCBoZWFkZXIsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoeyBtYXBXcml0YWJsZSwgZWFnZXJPcGVuOiB0cnVlIH0pXG5cbiAgICB0aGlzLndyaXR0ZW4gPSAwXG4gICAgdGhpcy5oZWFkZXIgPSBoZWFkZXJcblxuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLl9saW5rbmFtZSA9IG51bGxcbiAgICB0aGlzLl9pc0xpbmtuYW1lID0gaGVhZGVyLnR5cGUgPT09ICdzeW1saW5rJyAmJiAhaGVhZGVyLmxpbmtuYW1lXG4gICAgdGhpcy5faXNWb2lkID0gaGVhZGVyLnR5cGUgIT09ICdmaWxlJyAmJiBoZWFkZXIudHlwZSAhPT0gJ2NvbnRpZ3VvdXMtZmlsZSdcbiAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlXG4gICAgdGhpcy5fcGFjayA9IHBhY2tcbiAgICB0aGlzLl9vcGVuQ2FsbGJhY2sgPSBudWxsXG5cbiAgICBpZiAodGhpcy5fcGFjay5fc3RyZWFtID09PSBudWxsKSB0aGlzLl9wYWNrLl9zdHJlYW0gPSB0aGlzXG4gICAgZWxzZSB0aGlzLl9wYWNrLl9wZW5kaW5nLnB1c2godGhpcylcbiAgfVxuXG4gIF9vcGVuIChjYikge1xuICAgIHRoaXMuX29wZW5DYWxsYmFjayA9IGNiXG4gICAgaWYgKHRoaXMuX3BhY2suX3N0cmVhbSA9PT0gdGhpcykgdGhpcy5fY29udGludWVPcGVuKClcbiAgfVxuXG4gIF9jb250aW51ZVBhY2sgKGVycikge1xuICAgIGlmICh0aGlzLl9jYWxsYmFjayA9PT0gbnVsbCkgcmV0dXJuXG5cbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsXG5cbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cblxuICBfY29udGludWVPcGVuICgpIHtcbiAgICBpZiAodGhpcy5fcGFjay5fc3RyZWFtID09PSBudWxsKSB0aGlzLl9wYWNrLl9zdHJlYW0gPSB0aGlzXG5cbiAgICBjb25zdCBjYiA9IHRoaXMuX29wZW5DYWxsYmFja1xuICAgIHRoaXMuX29wZW5DYWxsYmFjayA9IG51bGxcbiAgICBpZiAoY2IgPT09IG51bGwpIHJldHVyblxuXG4gICAgaWYgKHRoaXMuX3BhY2suZGVzdHJveWluZykgcmV0dXJuIGNiKG5ldyBFcnJvcigncGFjayBzdHJlYW0gZGVzdHJveWVkJykpXG4gICAgaWYgKHRoaXMuX3BhY2suX2ZpbmFsaXplZCkgcmV0dXJuIGNiKG5ldyBFcnJvcigncGFjayBzdHJlYW0gaXMgYWxyZWFkeSBmaW5hbGl6ZWQnKSlcblxuICAgIHRoaXMuX3BhY2suX3N0cmVhbSA9IHRoaXNcblxuICAgIGlmICghdGhpcy5faXNMaW5rbmFtZSkge1xuICAgICAgdGhpcy5fcGFjay5fZW5jb2RlKHRoaXMuaGVhZGVyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc1ZvaWQpIHtcbiAgICAgIHRoaXMuX2ZpbmlzaCgpXG4gICAgICB0aGlzLl9jb250aW51ZVBhY2sobnVsbClcbiAgICB9XG5cbiAgICBjYihudWxsKVxuICB9XG5cbiAgX3dyaXRlIChkYXRhLCBjYikge1xuICAgIGlmICh0aGlzLl9pc0xpbmtuYW1lKSB7XG4gICAgICB0aGlzLl9saW5rbmFtZSA9IHRoaXMuX2xpbmtuYW1lID8gYjRhLmNvbmNhdChbdGhpcy5fbGlua25hbWUsIGRhdGFdKSA6IGRhdGFcbiAgICAgIHJldHVybiBjYihudWxsKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc1ZvaWQpIHtcbiAgICAgIGlmIChkYXRhLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ05vIGJvZHkgYWxsb3dlZCBmb3IgdGhpcyBlbnRyeScpKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNiKClcbiAgICB9XG5cbiAgICB0aGlzLndyaXR0ZW4gKz0gZGF0YS5ieXRlTGVuZ3RoXG4gICAgaWYgKHRoaXMuX3BhY2sucHVzaChkYXRhKSkgcmV0dXJuIGNiKClcbiAgICB0aGlzLl9wYWNrLl9kcmFpbiA9IGNiXG4gIH1cblxuICBfZmluaXNoICgpIHtcbiAgICBpZiAodGhpcy5fZmluaXNoZWQpIHJldHVyblxuICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZVxuXG4gICAgaWYgKHRoaXMuX2lzTGlua25hbWUpIHtcbiAgICAgIHRoaXMuaGVhZGVyLmxpbmtuYW1lID0gdGhpcy5fbGlua25hbWUgPyBiNGEudG9TdHJpbmcodGhpcy5fbGlua25hbWUsICd1dGYtOCcpIDogJydcbiAgICAgIHRoaXMuX3BhY2suX2VuY29kZSh0aGlzLmhlYWRlcilcbiAgICB9XG5cbiAgICBvdmVyZmxvdyh0aGlzLl9wYWNrLCB0aGlzLmhlYWRlci5zaXplKVxuXG4gICAgdGhpcy5fcGFjay5fZG9uZSh0aGlzKVxuICB9XG5cbiAgX2ZpbmFsIChjYikge1xuICAgIGlmICh0aGlzLndyaXR0ZW4gIT09IHRoaXMuaGVhZGVyLnNpemUpIHsgLy8gY29ycnVwdGluZyB0YXJcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1NpemUgbWlzbWF0Y2gnKSlcbiAgICB9XG5cbiAgICB0aGlzLl9maW5pc2goKVxuICAgIGNiKG51bGwpXG4gIH1cblxuICBfZ2V0RXJyb3IgKCkge1xuICAgIHJldHVybiBnZXRTdHJlYW1FcnJvcih0aGlzKSB8fCBuZXcgRXJyb3IoJ3RhciBlbnRyeSBkZXN0cm95ZWQnKVxuICB9XG5cbiAgX3ByZWRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX3BhY2suZGVzdHJveSh0aGlzLl9nZXRFcnJvcigpKVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGNiKSB7XG4gICAgdGhpcy5fcGFjay5fZG9uZSh0aGlzKVxuXG4gICAgdGhpcy5fY29udGludWVQYWNrKHRoaXMuX2ZpbmlzaGVkID8gbnVsbCA6IHRoaXMuX2dldEVycm9yKCkpXG5cbiAgICBjYigpXG4gIH1cbn1cblxuY2xhc3MgUGFjayBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXMuX2RyYWluID0gbm9vcFxuICAgIHRoaXMuX2ZpbmFsaXplZCA9IGZhbHNlXG4gICAgdGhpcy5fZmluYWxpemluZyA9IGZhbHNlXG4gICAgdGhpcy5fcGVuZGluZyA9IFtdXG4gICAgdGhpcy5fc3RyZWFtID0gbnVsbFxuICB9XG5cbiAgZW50cnkgKGhlYWRlciwgYnVmZmVyLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9maW5hbGl6ZWQgfHwgdGhpcy5kZXN0cm95aW5nKSB0aHJvdyBuZXcgRXJyb3IoJ2FscmVhZHkgZmluYWxpemVkIG9yIGRlc3Ryb3llZCcpXG5cbiAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBidWZmZXJcbiAgICAgIGJ1ZmZlciA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IG5vb3BcblxuICAgIGlmICghaGVhZGVyLnNpemUgfHwgaGVhZGVyLnR5cGUgPT09ICdzeW1saW5rJykgaGVhZGVyLnNpemUgPSAwXG4gICAgaWYgKCFoZWFkZXIudHlwZSkgaGVhZGVyLnR5cGUgPSBtb2RlVG9UeXBlKGhlYWRlci5tb2RlKVxuICAgIGlmICghaGVhZGVyLm1vZGUpIGhlYWRlci5tb2RlID0gaGVhZGVyLnR5cGUgPT09ICdkaXJlY3RvcnknID8gRE1PREUgOiBGTU9ERVxuICAgIGlmICghaGVhZGVyLnVpZCkgaGVhZGVyLnVpZCA9IDBcbiAgICBpZiAoIWhlYWRlci5naWQpIGhlYWRlci5naWQgPSAwXG4gICAgaWYgKCFoZWFkZXIubXRpbWUpIGhlYWRlci5tdGltZSA9IG5ldyBEYXRlKClcblxuICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykgYnVmZmVyID0gYjRhLmZyb20oYnVmZmVyKVxuXG4gICAgY29uc3Qgc2luayA9IG5ldyBTaW5rKHRoaXMsIGhlYWRlciwgY2FsbGJhY2spXG5cbiAgICBpZiAoYjRhLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgIGhlYWRlci5zaXplID0gYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgIHNpbmsud3JpdGUoYnVmZmVyKVxuICAgICAgc2luay5lbmQoKVxuICAgICAgcmV0dXJuIHNpbmtcbiAgICB9XG5cbiAgICBpZiAoc2luay5faXNWb2lkKSB7XG4gICAgICByZXR1cm4gc2lua1xuICAgIH1cblxuICAgIHJldHVybiBzaW5rXG4gIH1cblxuICBmaW5hbGl6ZSAoKSB7XG4gICAgaWYgKHRoaXMuX3N0cmVhbSB8fCB0aGlzLl9wZW5kaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX2ZpbmFsaXppbmcgPSB0cnVlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZmluYWxpemVkKSByZXR1cm5cbiAgICB0aGlzLl9maW5hbGl6ZWQgPSB0cnVlXG5cbiAgICB0aGlzLnB1c2goRU5EX09GX1RBUilcbiAgICB0aGlzLnB1c2gobnVsbClcbiAgfVxuXG4gIF9kb25lIChzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtICE9PSB0aGlzLl9zdHJlYW0pIHJldHVyblxuXG4gICAgdGhpcy5fc3RyZWFtID0gbnVsbFxuXG4gICAgaWYgKHRoaXMuX2ZpbmFsaXppbmcpIHRoaXMuZmluYWxpemUoKVxuICAgIGlmICh0aGlzLl9wZW5kaW5nLmxlbmd0aCkgdGhpcy5fcGVuZGluZy5zaGlmdCgpLl9jb250aW51ZU9wZW4oKVxuICB9XG5cbiAgX2VuY29kZSAoaGVhZGVyKSB7XG4gICAgaWYgKCFoZWFkZXIucGF4KSB7XG4gICAgICBjb25zdCBidWYgPSBoZWFkZXJzLmVuY29kZShoZWFkZXIpXG4gICAgICBpZiAoYnVmKSB7XG4gICAgICAgIHRoaXMucHVzaChidWYpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9lbmNvZGVQYXgoaGVhZGVyKVxuICB9XG5cbiAgX2VuY29kZVBheCAoaGVhZGVyKSB7XG4gICAgY29uc3QgcGF4SGVhZGVyID0gaGVhZGVycy5lbmNvZGVQYXgoe1xuICAgICAgbmFtZTogaGVhZGVyLm5hbWUsXG4gICAgICBsaW5rbmFtZTogaGVhZGVyLmxpbmtuYW1lLFxuICAgICAgcGF4OiBoZWFkZXIucGF4XG4gICAgfSlcblxuICAgIGNvbnN0IG5ld0hlYWRlciA9IHtcbiAgICAgIG5hbWU6ICdQYXhIZWFkZXInLFxuICAgICAgbW9kZTogaGVhZGVyLm1vZGUsXG4gICAgICB1aWQ6IGhlYWRlci51aWQsXG4gICAgICBnaWQ6IGhlYWRlci5naWQsXG4gICAgICBzaXplOiBwYXhIZWFkZXIuYnl0ZUxlbmd0aCxcbiAgICAgIG10aW1lOiBoZWFkZXIubXRpbWUsXG4gICAgICB0eXBlOiAncGF4LWhlYWRlcicsXG4gICAgICBsaW5rbmFtZTogaGVhZGVyLmxpbmtuYW1lICYmICdQYXhIZWFkZXInLFxuICAgICAgdW5hbWU6IGhlYWRlci51bmFtZSxcbiAgICAgIGduYW1lOiBoZWFkZXIuZ25hbWUsXG4gICAgICBkZXZtYWpvcjogaGVhZGVyLmRldm1ham9yLFxuICAgICAgZGV2bWlub3I6IGhlYWRlci5kZXZtaW5vclxuICAgIH1cblxuICAgIHRoaXMucHVzaChoZWFkZXJzLmVuY29kZShuZXdIZWFkZXIpKVxuICAgIHRoaXMucHVzaChwYXhIZWFkZXIpXG4gICAgb3ZlcmZsb3codGhpcywgcGF4SGVhZGVyLmJ5dGVMZW5ndGgpXG5cbiAgICBuZXdIZWFkZXIuc2l6ZSA9IGhlYWRlci5zaXplXG4gICAgbmV3SGVhZGVyLnR5cGUgPSBoZWFkZXIudHlwZVxuICAgIHRoaXMucHVzaChoZWFkZXJzLmVuY29kZShuZXdIZWFkZXIpKVxuICB9XG5cbiAgX2RvRHJhaW4gKCkge1xuICAgIGNvbnN0IGRyYWluID0gdGhpcy5fZHJhaW5cbiAgICB0aGlzLl9kcmFpbiA9IG5vb3BcbiAgICBkcmFpbigpXG4gIH1cblxuICBfcHJlZGVzdHJveSAoKSB7XG4gICAgY29uc3QgZXJyID0gZ2V0U3RyZWFtRXJyb3IodGhpcylcblxuICAgIGlmICh0aGlzLl9zdHJlYW0pIHRoaXMuX3N0cmVhbS5kZXN0cm95KGVycilcblxuICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fcGVuZGluZy5zaGlmdCgpXG4gICAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gICAgICBzdHJlYW0uX2NvbnRpbnVlT3BlbigpXG4gICAgfVxuXG4gICAgdGhpcy5fZG9EcmFpbigpXG4gIH1cblxuICBfcmVhZCAoY2IpIHtcbiAgICB0aGlzLl9kb0RyYWluKClcbiAgICBjYigpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYWNrIChvcHRzKSB7XG4gIHJldHVybiBuZXcgUGFjayhvcHRzKVxufVxuXG5mdW5jdGlvbiBtb2RlVG9UeXBlIChtb2RlKSB7XG4gIHN3aXRjaCAobW9kZSAmIGNvbnN0YW50cy5TX0lGTVQpIHtcbiAgICBjYXNlIGNvbnN0YW50cy5TX0lGQkxLOiByZXR1cm4gJ2Jsb2NrLWRldmljZSdcbiAgICBjYXNlIGNvbnN0YW50cy5TX0lGQ0hSOiByZXR1cm4gJ2NoYXJhY3Rlci1kZXZpY2UnXG4gICAgY2FzZSBjb25zdGFudHMuU19JRkRJUjogcmV0dXJuICdkaXJlY3RvcnknXG4gICAgY2FzZSBjb25zdGFudHMuU19JRklGTzogcmV0dXJuICdmaWZvJ1xuICAgIGNhc2UgY29uc3RhbnRzLlNfSUZMTks6IHJldHVybiAnc3ltbGluaydcbiAgfVxuXG4gIHJldHVybiAnZmlsZSdcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBvdmVyZmxvdyAoc2VsZiwgc2l6ZSkge1xuICBzaXplICY9IDUxMVxuICBpZiAoc2l6ZSkgc2VsZi5wdXNoKEVORF9PRl9UQVIuc3ViYXJyYXkoMCwgNTEyIC0gc2l6ZSkpXG59XG5cbmZ1bmN0aW9uIG1hcFdyaXRhYmxlIChidWYpIHtcbiAgcmV0dXJuIGI0YS5pc0J1ZmZlcihidWYpID8gYnVmIDogYjRhLmZyb20oYnVmKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar-stream/pack.js\n");

/***/ })

};
;